<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sapio Language Bible</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Sapio Language</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">ABC 123</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installing Sapio</a></li><li class="chapter-item expanded "><a href="ch01-02-learn-rust.html"><strong aria-hidden="true">1.2.</strong> Learning Rust</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-world.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-bip-119.html"><strong aria-hidden="true">2.</strong> BIP-119 CTV Fundamentals</a></li><li class="chapter-item expanded "><a href="ch03-00-basics.html"><strong aria-hidden="true">3.</strong> Sapio Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-guts.html"><strong aria-hidden="true">3.1.</strong> Contract Guts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-miniscript.html"><strong aria-hidden="true">3.1.1.</strong> Miniscript/Policy</a></li><li class="chapter-item expanded "><a href="ch03-01-builder.html"><strong aria-hidden="true">3.1.2.</strong> Template Builder</a></li><li class="chapter-item expanded "><a href="ch03-01-timelocks.html"><strong aria-hidden="true">3.1.3.</strong> Time Locks</a></li><li class="chapter-item expanded "><a href="ch03-01-amounts.html"><strong aria-hidden="true">3.1.4.</strong> Sats and Coins</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-02-guts.html"><strong aria-hidden="true">3.2.</strong> Contract Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-02-guard.html"><strong aria-hidden="true">3.2.1.</strong> guard!</a></li><li class="chapter-item expanded "><a href="ch03-02-compile_if.html"><strong aria-hidden="true">3.2.2.</strong> compile_if!</a></li><li class="chapter-item expanded "><a href="ch03-02-then.html"><strong aria-hidden="true">3.2.3.</strong> then!</a></li><li class="chapter-item expanded "><a href="ch03-02-finish.html"><strong aria-hidden="true">3.2.4.</strong> finish!</a></li><li class="chapter-item expanded "><a href="ch03-02-when-use-macros.html"><strong aria-hidden="true">3.2.5.</strong> When to use macros?</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-03-declarations.html"><strong aria-hidden="true">3.3.</strong> Contract Declarations</a></li><li class="chapter-item expanded "><a href="ch03-04-compliation.html"><strong aria-hidden="true">3.4.</strong> Contract Compilation Overview</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Exercises</li><li class="chapter-item expanded "><a href="ch04-00-sapio-fun-profit.html"><strong aria-hidden="true">4.</strong> Sapio for Fun (and Profit)</a></li><li class="chapter-item expanded affix "><li class="part-title">Warnings</li><li class="chapter-item expanded "><a href="ch05-00-limitations.html"><strong aria-hidden="true">5.</strong> Limitations of Sapio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ctv-emulator.html"><strong aria-hidden="true">5.1.</strong> BIP-119 Emulation</a></li><li class="chapter-item expanded "><a href="ch05-02-taproot.html"><strong aria-hidden="true">5.2.</strong> No Taproot</a></li><li class="chapter-item expanded "><a href="ch05-03-txns.html"><strong aria-hidden="true">5.3.</strong> Advanced Transaction Handling</a></li><li class="chapter-item expanded "><a href="ch05-04-gas.html"><strong aria-hidden="true">5.4.</strong> Mempool &amp; Fees</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="ch06-00-packaging.html"><strong aria-hidden="true">6.</strong> Application Packaging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-wasm.html"><strong aria-hidden="true">6.1.</strong> WASM</a></li><li class="chapter-item expanded "><a href="ch06-02-rust.html"><strong aria-hidden="true">6.2.</strong> Rust Lib</a></li><li class="chapter-item expanded "><a href="ch06-02-tux.html"><strong aria-hidden="true">6.3.</strong> TUX</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-cli.html"><strong aria-hidden="true">7.</strong> Sapio CLI</a></li><li class="chapter-item expanded "><a href="ch08-00-useful-rust.html"><strong aria-hidden="true">8.</strong> Advanced Rust Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-state-machines.html"><strong aria-hidden="true">8.1.</strong> Type Level State Machines</a></li><li class="chapter-item expanded "><a href="ch08-02-tryfrom.html"><strong aria-hidden="true">8.2.</strong> TryFrom Constructors</a></li><li class="chapter-item expanded "><a href="ch08-03-concrete.html"><strong aria-hidden="true">8.3.</strong> Concrete Wrappers</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Sapio Language Bible</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/sapio-lang/sapio" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sapio-language-bible"><a class="header" href="#the-sapio-language-bible">The Sapio Language Bible</a></h1>
<h1 id="a-hrefhttpsgithubcomsapio-langsapioactionsquerybranch3amasterimg-srchttpsgithubcomsapio-langsapioworkflowscontinuous20integrationbadgesvg-altbuild-status-a-a-hrefhttpscratesiocratessapioimg-srchttpsimgshieldsiocratesdvsapio-altcrates-a-a-hrefhttpsdocsrssapioimg-srchttpsimgshieldsiodocsrssapiolatest-altdocs-a-a-hrefhttpsgithubcomsapio-langsapioforkimg-srchttpsimgshieldsiogithubforkssapio-langsapiolabelfork20mestylesocial-altforkme-a"><a class="header" href="#a-hrefhttpsgithubcomsapio-langsapioactionsquerybranch3amasterimg-srchttpsgithubcomsapio-langsapioworkflowscontinuous20integrationbadgesvg-altbuild-status-a-a-hrefhttpscratesiocratessapioimg-srchttpsimgshieldsiocratesdvsapio-altcrates-a-a-hrefhttpsdocsrssapioimg-srchttpsimgshieldsiodocsrssapiolatest-altdocs-a-a-hrefhttpsgithubcomsapio-langsapioforkimg-srchttpsimgshieldsiogithubforkssapio-langsapiolabelfork20mestylesocial-altforkme-a"><a href="https://github.com/sapio-lang/sapio/actions?query=branch%3Amaster"><img src="https://github.com/sapio-lang/sapio/workflows/Continuous%20integration/badge.svg" alt="Build Status" /></a> <a href="https://crates.io/crates/sapio"><img src="https://img.shields.io/crates/dv/sapio" alt="crates" /></a> <a href="https://docs.rs/sapio"><img src="https://img.shields.io/docsrs/sapio/latest" alt="docs" /></a> <a href="https://github.com/sapio-lang/sapio/fork"><img src="https://img.shields.io/github/forks/sapio-lang/sapio?label=Fork%20Me&amp;style=social" alt="forkme" /></a></a></h1>
<p><em>A practical guide to engineering bitcoin smart contracts using the Sapio Language.</em></p>
<img src="https://github.com/sapio-lang/sapio/raw/master/.github/logo.png" alt="Say hi to Jared">
<p>This book is a work in progress! Please <a href="https://github.com/sapio-lang/sapio">submit a PR</a> with
improvements or suggestions.</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h1 id="installing-sapio"><a class="header" href="#installing-sapio">Installing Sapio</a></h1>
<h2 id="quickstart"><a class="header" href="#quickstart">QuickStart:</a></h2>
<p>Sapio should work on all platforms, but is recommend for use with Linux (Ubuntu preferred).
Follow this quickstart guide to get going.</p>
<ol>
<li>Get <a href="https://rustup.rs/">rust</a> if you don't have it already.</li>
<li>Add the wasm target by running the below command in your terminal:</li>
</ol>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<ol>
<li>Get the <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a> tool.</li>
<li>Clone this repo: </li>
</ol>
<pre><code>git clone git@github.com:sapio-lang/sapio.git &amp;&amp; cd sapio
</code></pre>
<ol>
<li>[Optional] To use dependencies from <a href="https://crates.io">crates.io</a></li>
</ol>
<pre><code>git checkout v0.1.4 &amp;&amp; cp plugin-example .. &amp;&amp; cd ..
</code></pre>
<ol>
<li>Build the plugin</li>
</ol>
<pre><code>cd plugin-example &amp;&amp; wasm-pack build &amp;&amp; cd ..
</code></pre>
<ol>
<li>Instantiate a contract from the plugin:</li>
</ol>
<pre><code>cargo run --bin sapio-cli -- contract create 9.99 &quot;{\&quot;participants\&quot;: [{\&quot;amount\&quot;: 9.99, \&quot;address\&quot;: \&quot;bcrt1qs758ursh4q9z627kt3pp5yysm78ddny6txaqgw\&quot;}], \&quot;radix\&quot;: 2}&quot; --file=&quot;plugin-example/pkg/sapio_wasm_plugin_example_bg.wasm&quot;
</code></pre>
<p>You can use <code>cargo run --bin sapio-cli -- help</code> to learn more about what a the CLI
can do! and <code>cargo run --bin sapio-cli -- &lt;subcommand&gt; help</code> to learn about
subcommands like <code>contract</code>.</p>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>You can review the docs either by building them locally or viewing
<a href="https://docs.rs/sapio">online</a>.</p>
<h1 id="learning-rust"><a class="header" href="#learning-rust">Learning Rust</a></h1>
<p>A full rust tutorial is out of scope for this guide.</p>
<p>You may wish to begin with <a href="https://doc.rust-lang.org/book/">The Rust Programming
Language</a>.</p>
<p>Expertise in Rust is not <em>required</em> to be a fluent Sapio developer, but it
helps. Typical Sapio programs are relatively simple as we are not typically
concerned with concurrency or memory efficiency.</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's get going with your very first hello world contract!</p>
<p>Unfortunately, until Sapio becomes a little more popular the embedded rust
playground won't work, so you'll want to copy it locally.</p>
<p>We're going to start with a contract that allows two parties, Alice and Bob,
to either agree on an outcome or to default to a pre-fixed outcome after a
relative timeout.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitcoin::util::amount::CoinAmount;
use sapio::contract::*;
use sapio::*;
use sapio_base::timelocks::RelTime;
use sapio_base::Clause;
pub struct TrustlessEscrow {
    alice: bitcoin::PublicKey,
    bob: bitcoin::PublicKey,
    alice_escrow: (CoinAmount, bitcoin::Address),
    bob_escrow: (CoinAmount, bitcoin::Address),
}

impl TrustlessEscrow {
    guard! {
        fn cooperate(self, ctx) {
            Clause::And(vec![Clause::Key(self.alice), Clause::Key(self.bob)])
        }
    }
    then! {
        fn use_escrow(self, ctx) {
            ctx.template()
                .add_output(
                    self.alice_escrow.0.try_into()?,
                    &amp;Compiled::from_address(self.alice_escrow.1.clone(), None),
                    None)?
                .add_output(
                    self.bob_escrow.0.try_into()?,
                    &amp;Compiled::from_address(self.bob_escrow.1.clone(), None),
                    None)?
                .set_sequence(0, RelTime::try_from(std::time::Duration::from_secs(10*24*60*60))?.into())?.into()
        }
    }
}

impl Contract for TrustlessEscrow {
    declare! {finish, Self::cooperate}
    declare! {then, Self::use_escrow}
    declare! {non updatable}
}
<span class="boring">}
</span></code></pre></pre>
<p>Create a new rust project and paste the above code in. You should be able to
compile it using <code>cargo build</code>. </p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<ol>
<li>Add a new finish state that allows Alice to spend after a relative timeout.</li>
<li>Add <code>use_escrow2</code> which enables a different pair of payouts to Alice and
Bob as an alternative.</li>
</ol>
<h1 id="bip-119-ctv-fundamentals"><a class="header" href="#bip-119-ctv-fundamentals">BIP-119 CTV Fundamentals</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>BIP-119 OP_CHECKTEMPLATEVERIFY (CTV) is a
<a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki">proposed</a>
soft-fork upgrade to Bitcoin for enabling a bevy of use cases.</p>
<p>At it's core, CTV enables a script to commit to the &quot;important bits&quot; of how it can be spent, or the:</p>
<ol>
<li>nVersion</li>
<li>nLockTime</li>
<li>scriptSig hash (maybe!)</li>
<li>input count</li>
<li>sequences hash</li>
<li>output count</li>
<li>outputs hash</li>
<li>input index</li>
</ol>
<p>This enables a myriad of use cases, which are described in detail in the
<a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki">BIP</a> and on
the website <a href="https://utxos.org">utxos.org</a>.</p>
<h2 id="how-do-we-think-about-smart-contracts-and-ctv"><a class="header" href="#how-do-we-think-about-smart-contracts-and-ctv">How do we think about Smart Contracts and CTV?</a></h2>
<p>Before CTV, in most Bitcoin smart contracts, we think at the key-level. That
is, what is a complex set of signers and satisfactions to unlock a specific
coin. But once we unlock a coin, the smart contract usually does not encode
any further restrictions on how it may be spent.</p>
<p>You could think of this as &quot;a key to a car&quot;. If it unlocks the car, you can
take the car wherever you want.</p>
<p>With CTV, we hope to encode a bit more information about how coins should
move by providing the paths that the coins must move through as well. So
rather than just being the key to a car, you could think of it a bit more
like the keys to train -- still required to start the engine, but you have to
stay on the tracks and there is a finite number of tracks to pick at any
juncture.</p>
<p>That's all a bit abstract. This back to the Hello World example we gave. We
created a coin with the following options:</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout \( \rightarrow \) coins go back to Alice and Bob</li>
</ol>
<p>Now imagine we wanted to change the rules a little. What if instead of rule 2
apply after a timeout, what if we wanted the timeout to be measured <em>from the
time that Alice or Bob claimed they wanted to use the escrow</em>.</p>
<p>This puts us in a little bit of a pickle. Sure we could just re-write the rules:</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout <em>since Alice or Bob requested</em> \( \rightarrow \) coins go back to Alice and Bob</li>
</ol>
<p>But Bitcoin doesn't have a script level notion of &quot;since&quot; a part of a witness was constructed. The CTV way to think of this script is to define a state machine with two states \( S \in \{Normal, Closing\}\) and the rules:</p>
<ul>
<li>
<p>\( S \gets Normal\):</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Alice or Bob Requested \( \rightarrow \) (\(S \gets Closing \))</li>
</ol>
</li>
<li>
<p>\( S \gets Closing\):</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout <em>since</em> (\(S \gets Closing\)) \( \rightarrow \) coins go back to Alice and Bob.</li>
</ol>
</li>
</ul>
<p>What drives the transition from Normal to Closing? Just a standard Bitcoin transaction!</p>
<h2 id="so-what-is-sapio"><a class="header" href="#so-what-is-sapio">So What is Sapio</a></h2>
<p>Sapio is an embedded domain specific language for defining these sorts of
state transition rules to build smart contracts for Bitcoin.</p>
<p>CTV is used as the mechanism to enforce that specific state transitions occur.</p>
<p>When we <strong>write</strong> a program in Sapio, we are designing an <em>arbitrary</em> state
machine that can run any program.</p>
<p>When we <strong>compile</strong> a Sapio program, we run that state machine to completion and merkelize the resultant program states into a fixed graph.</p>
<p>As such, Sapio  is a very powerful framework for designing Bitcoin smart contracts, but we're constrained to the set of contracts where we can enumerate all possible end states.</p>
<p>To get around these restrictions, Sapio has some tricks up it's sleeve that
will be described in future chapters.</p>
<h1 id="sapio-basics"><a class="header" href="#sapio-basics">Sapio Basics</a></h1>
<p>This section is intended to introduce the basic components of Sapio and how
they are used. It's a nice complement to the material avaialble in the
<a href="https://docs.rs/sapio">online docs</a>, which are more targetted to everyday users.</p>
<h1 id="contract-guts"><a class="header" href="#contract-guts">Contract Guts</a></h1>
<p>This section covers basic modules and primitives that are handy to know as
you navigate Sapio contracts.</p>
<p>Feel free to skip this section and refer back to it as needed!</p>
<h1 id="miniscript--policy"><a class="header" href="#miniscript--policy">Miniscript &amp; Policy</a></h1>
<p>Miniscript &amp; Policy are tools for creating well formed Bitcoin scripts
developed by Blockstream developers Pieter Wiulle, Andrew Poelstra, and
Sanket Kanjalkar.</p>
<p>from the <a href="http://bitcoin.sipa.be/miniscript/">miniscript website</a>:</p>
<blockquote>
<p>Miniscript is a language for writing (a subset of) Bitcoin Scripts in a
structured way, enabling analysis, composition, generic signing and more.</p>
<p>Bitcoin Script is an unusual stack-based language with many edge cases,
designed for implementing spending conditions consisting of various
combinations of signatures, hash locks, and time locks. Yet despite being
limited in functionality it is still highly nontrivial to:</p>
<ol>
<li>Given a combination of spending conditions, finding the most economical script to implement it.</li>
<li>Given two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the &quot;keys&quot; is another multisig).</li>
<li>Given a script, find out what spending conditions it permits.</li>
<li>Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.</li>
<li>Given a script, be able to predict the cost of spending an output.</li>
<li>Given a script, know whether particular resource limitations like the ops limit might be hit when spending.</li>
</ol>
<p>Miniscript functions as a representation for scripts that makes these sort of
operations possible. It has a structure that allows composition. It is very
easy to statically analyze for various properties (spending conditions,
correctness, security properties, malleability, ...). It can be targeted by
spending policy compilers (see below). Finally, compatible scripts can easily
be converted to Miniscript form - avoiding the need for additional metadata
for e.g. signing devices that support it.</p>
</blockquote>
<p>For Sapio, we use a customized
<a href="https://github.com/sapio-lang/rust-miniscript">rust-miniscript</a> which
extends miniscript with functionality relevent to CheckTemplateVerify and
Sapio. All changes should be able to be upstreamed eventually.</p>
<p>The Policy type (named Clause in Sapio) allows us to specify the predicates upon which various state transitions should unlock.</p>
<p>This makes it so that Sapio should be compatible with other software that can
generate valid Policies, and compatible with PSBT signing devices that
understand how to satisfy miniscripts.</p>
<p>A limitation of this approach is that there are certain types of script which
are possible, but not yet supported in Sapio. For example, the <code>OP_SIZE</code>
coinflip script is not currently possible with Miniscript.</p>
<h1 id="template-builder"><a class="header" href="#template-builder">Template Builder</a></h1>
<h1 id="time-locks"><a class="header" href="#time-locks">Time Locks</a></h1>
<p>Sapio provides some utilities for working with both relative and absolute timelocks. See <a href="https://docs.rs/sapio-base/0.1.0/sapio_base/timelocks/index.html">the sapio-base docs</a> for more details.</p>
<p>The Time Lock Utilities have some nice interfaces for dealing with timelocks generically and converting them into Policy Clauses.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use sapio_base::timelocks::*;
use std::time::Duration;

AbsHeight::try_from(800_000u32);
AbsTime::try_from(1_000_000_000u32);
AbsTime::try_from(Duration::from_secs(1_000_000_000u64));
// chunks of 512 seconds
RelTime::from(10u16);
RelTime::try_from(Duration::from_secs(10*512));
RelHeight::from(20u16);


// Correctly compiles into Clause::Older
let c: Clause = RelHeight::from(20u16).into();

let a: AnyRelTimeLock = RelHeight::from(20u16).into();
let b: AnyTimeLock = RelHeight::from(20u16).into();

<span class="boring">}
</span></code></pre></pre>
<p>These are not required to be used, but care should be taken if not used to
ensure that correct values are passed to the miniscript compiler.</p>
<h1 id="sats-and-coins"><a class="header" href="#sats-and-coins">Sats and Coins</a></h1>
<p>There are several different ways of expressing amounts in Sapio.</p>
<p>That there isn't a single canonical way to represent amounts is unfortunate,
and hopefully these types can be fully unified in the future. But it's a
problem for good reason.</p>
<h2 id="a-brief-rant"><a class="header" href="#a-brief-rant">A brief rant</a></h2>
<p>Suppose I tell you to send 10 to Alice. Is that 10 sats? or 10 bitcoin? You
might think that 10.0 would be unambiguous, but it turns out the lightning
network is building sub-satoshi support.</p>
<p>The <em>only</em> way to make context-free unambiguous amounts is to have them
explicityly tagged, e.g., {denom: &quot;sats&quot;, amount: 10}.</p>
<p>This would be great, but there are already myriads of services out there
where the only way to know what unit you have is to RTFM.</p>
<p>Generally, we know that floating point representations are evil for financial
transactions, but because we want to be compatible with JSON/Javascript, we
don't quite have a choice. Fortunately, 21e6 Bitcoin with 8 places fit
exactly into floats without loss. However, bets are off when doing arithmetic
with such values.</p>
<p>A last wrinkle: Bitcoin's amount type is a signed integer. Rust-bitcoin uses an Unsigned integer. So in theory there are unrepresentable amounts we're happy to work with. Great.</p>
<h2 id="its-up-to-every-programmer"><a class="header" href="#its-up-to-every-programmer">It's up to every programmer</a></h2>
<p>Therefore, to get amounts right is a task that is up to the programmer
largely to get this right. There are a few different amount types to be aware
of.</p>
<ol>
<li>u64 represents sats. may be too big!</li>
<li>i64 represents sats. may be too small!</li>
<li><code>bitcoin::Amount</code> represents u64, no standard serialization.</li>
<li><code>bitcoin::SignedAmount</code> represents i64, no standard serialization.</li>
<li><code>bitcoin::CoinAmount</code> standard tagged serialization, either u64 or f64.</li>
</ol>
<p>These different types have uses in different circumstances.</p>
<p>Because <code>bitcoin::Amount</code> does not have a standard serializer, in order to
use it in e.g. a <code>Vec</code>, you have to wrap the type with a a serializer. <code>From</code> impls can make life a little eaiser to work with these.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitcoin::util::amount::Amount;

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// A wrapper around `bitcoin::Amount` to force it to serialize with f64.
#[derive(
    Serialize, Deserialize, JsonSchema, Clone, Copy, Debug, Ord, PartialOrd, PartialEq, Eq,
)]
#[serde(transparent)]
struct AmountF64(
    #[schemars(with = &quot;f64&quot;)]
    #[serde(with = &quot;bitcoin::util::amount::serde::as_btc&quot;)]
    Amount,
);

impl From&lt;Amount&gt; for AmountF64 {
    fn from(a: Amount) -&gt; AmountF64 {
        AmountF64(a)
    }
}
impl From&lt;AmountF64&gt; for Amount {
    fn from(a: AmountF64) -&gt; Amount {
        a.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>CoinAmount</code> does not have this problem, but it can't be used in all
contexts, e.g. extenral APIs that aren't tagged.</p>
<h2 id="dont-panic-or-do"><a class="header" href="#dont-panic-or-do">Don't Panic (or do)</a></h2>
<p>A final annoyance is that <code>bitcoin::Amount</code> has arithmetic that may panic
(unless you use the <code>checked_</code> variants). So one must be careful to ensure
that any set of values passed in are safe to add.</p>
<p>Sapio currently does not do a fantastic job of this, but that can be improved
in the future.</p>
<h1 id="contract-actions"><a class="header" href="#contract-actions">Contract Actions</a></h1>
<h1 id="guard"><a class="header" href="#guard">Guard</a></h1>
<p>Guards are central to any Sapio contract. The allow declaring a piece of
miniscript logic.</p>
<p>These guards can either be used standalone as unlocking condtions or as a
requirement on a <code>finish!</code> or <code>then!</code> function.</p>
<p>If a <code>guard!</code> is marked as cached, the compiler will make an effort to only
invoke the <code>guard!</code> once during compilation. This is helpful in contexts
where a <code>guard!</code> might be expensive to call, e.g. if it is programmed to
retreive a <code>Clause</code> from a remote server. It is not guaranteed that the
<code>guard!</code> is only invoked once.</p>
<h2 id="guard-macro"><a class="header" href="#guard-macro">guard! macro</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>guard!{
    fn name(self, ctx) {/*Clause*/}
}
/// The guard should only be invoked once by the compiler, and the result stored
guard!{
    cached fn name(self, ctx) {/*Clause*/}
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="conditionallycompileif"><a class="header" href="#conditionallycompileif">ConditionallyCompileIf</a></h1>
<p><code>ConditionallyCompileIf</code> enables a contract writer to evaluate certain
value-based logic before evaluating a path function.</p>
<p>If the return value(s) indicate that a branch should not be evaluated, it is
skipped.</p>
<h2 id="when-to-use-conditionallycompileif"><a class="header" href="#when-to-use-conditionallycompileif">When to Use ConditionallyCompileIf</a></h2>
<p>Suppose we're creating a super secure wallet vault, and we want a recovery
path that's only acessible if the amount of funds being sent to the contract is &lt; an amount.</p>
<p>We could write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>compile_if!{
    fn not_too_much(self, ctx) {
        if ctx.funds() &gt; Self::MAX_FUNDS {
            ConditionallyCompileType::Never
        } else {
            ConditionalCompileType::NoConstraint
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>and apply it to the relevent paths.</p>
<h2 id="conditionalcompiletype-variants"><a class="header" href="#conditionalcompiletype-variants">ConditionalCompileType Variants</a></h2>
<p>There are many different ConditionalCompileType return values:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ConditionalCompileType {
    /// May proceed without calling this function at all
    Skippable,
    /// If no errors are returned, and no txtmpls are returned,
    /// it is not an error and the branch is pruned.
    Nullable,
    /// The default condition if no ConditionallyCompileIf function is set, the
    /// branch is present and it is required.
    Required,
    /// This branch must never be used
    Never,
    /// No Constraint, nothing is changed by this rule
    NoConstraint,
    /// The branch should always trigger an error, with some reasons
    Fail(LinkedList&lt;String&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>These values are merged according to specific &quot;common sense&quot; logic. Please
see <code>ConditionalCompileType::merge</code> for details.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    ///     Fail &gt; non-Fail ==&gt; Fail
    ///     forall X. X &gt; NoConstraint ==&gt; X
    ///     Required &gt; {Skippable, Nullable} ==&gt; Required
    ///     Skippable &gt; Nullable ==&gt; Skippable
    ///     Never &gt;&lt; Required ==&gt; Fail
    ///     Never &gt; {Skippable, Nullable}  ==&gt; Never
<span class="boring">}
</span></code></pre></pre>
<h1 id="compile_if-macro"><a class="header" href="#compile_if-macro">compile_if! macro</a></h1>
<p>The <code>compile_if</code> macro can be called two ways:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>compile_if!{
    fn name(self, ctx) {
        /*ConditionalCompileType*/
    }
}
/// null implementation
compile_if!{name}
<span class="boring">}
</span></code></pre></pre>
<h1 id="thenfunc"><a class="header" href="#thenfunc">ThenFunc</a></h1>
<p>A <code>ThenFunc</code> is a continuation of a contract that can proceed when all the
guarded_by conditions on that object are met. The <code>ThenFunc</code> provides an
iterator of possible next transactions, using CTV to ensure execution.</p>
<h2 id="when-to-use-a-thenfunc"><a class="header" href="#when-to-use-a-thenfunc">When to use a ThenFunc</a></h2>
<p>We've already seen an example of a <code>then!</code> function in the wild in <a href="./ch01-03-hello-world.html">Chapter
1</a>. In that example we are guaranteeing that after
a timeout, a specific &quot;return policy&quot; is honored out of the escrow. Unless
Alice and Bob agree to something else, the funds can only be returned via
that transaction.</p>
<p>In general, any time you want a state transition to be &quot;locked in&quot; you should use a <code>then!</code>.</p>
<h2 id="then-macro"><a class="header" href="#then-macro">then! macro</a></h2>
<p>The <code>then!</code> macro generates a static <code>fn() -&gt; Option&lt;ThenFunc&gt;</code> method for a given impl.</p>
<p>There are a few variants of how you can create a <code>then!</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A Guarded CTV Function
then!{
    guarded_by: [guard_1, ... guard_n]
    fn name(self, ctx) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// A Conditional CTV Function
then!{
    compile_if: [compile_if_1, ... compile_if_n]
    fn name(self, ctx) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// A Conditional + Guarded CTV Function
then!{
    compile_if: [compile_if_1, ... compile_if_n]
    guarded_by: [guard_1, ... guard_n]
    fn name(self, ctx) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// An Unguarded CTV Function
then!{
    fn name(self, ctx) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// Null Implementation
then!{name}
<span class="boring">}
</span></code></pre></pre>
<p>The Iterator must not be empty, or it will cause an error.</p>
<h1 id="finishorfunc"><a class="header" href="#finishorfunc">FinishOrFunc</a></h1>
<p>A <code>FinishOrFunc</code> is a continuation of a contract that <em>may</em> terminate when
all the guarded_by conditions on that object are met, but provides logic for some default continuations and logic for new continuations in light of new information.</p>
<p><code>FinishOrFunc</code>s do not use CTV to ensure execution.</p>
<h2 id="when-to-use-a-finishorfunc"><a class="header" href="#when-to-use-a-finishorfunc">When to use a FinishOrFunc</a></h2>
<p>An example of where a <code>FinishOrFunc</code> could be used is a multisig escrow contract, where if n-of-n interested parties agree to move the funds, the funds can move to any transaction. However, perhaps the escrow operators typically emit a payment to a third party and carry the remaining balances to a new escrow. A <code>FinishOrFunc</code> can provide convenient logic shared by all participants for generating what that next transaction should look like.</p>
<h2 id="finish-macro"><a class="header" href="#finish-macro">finish! macro</a></h2>
<p>The <code>finish!</code> macro generates a static <code>fn() -&gt; Option&lt;FinishOrFunc&gt;</code> method for a given impl.</p>
<p>There are a few variants of how you can create a <code>finish!</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A Guarded CTV Function
finish!{
    guarded_by: [guard_1, ... guard_n]
    fn name(self, ctx, o) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// A Conditional CTV Function
finish!{
    compile_if: [compile_if_1, ... compile_if_n]
    guarded_by: [guard_1, ... guard_n]
    fn name(self, ctx, o) {
        /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
    }
}
/// Null Implementation
finish!(name);
<span class="boring">}
</span></code></pre></pre>
<p>The type of the parameter <code>o</code> is <code>Option&lt;&lt;Self as Contract&gt;::StatefulArguments&gt;</code> and is the same across all <code>FinishOrFunc</code>s. Enums may be used to pass different arguments to different functions.</p>
<h1 id="when-to-use-macros"><a class="header" href="#when-to-use-macros">When to use macros?</a></h1>
<p>Generally, you want to use <code>finish!</code>, <code>then!</code>, etc to generate your methods.
However, if you prefer to create them manually, it's entirely possible to do
so without much effort. A tool like <code>cargo expand</code> may be useful as you can
just copy the macro output and customize from there.</p>
<p>One reason you might choose to manually define them is if you want to have
custom static logic (that is, known just from the type and not a value-filled
instance) to decide if a method should be <code>Some</code> or <code>None</code>. If it does not
need to be static logic, a <code>compile_if</code> can be used.</p>
<h1 id="contract-declarations"><a class="header" href="#contract-declarations">Contract Declarations</a></h1>
<h2 id="static-contracts"><a class="header" href="#static-contracts">Static Contracts</a></h2>
<p>This is the usual way to declare a contract for Sapio.</p>
<p>Once a contract and all relevent logic has been defined, a <code>impl Contract</code>
should be written. This binds the functionality to the compiler interface.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Contract for T {
    declare!{then, Self::a, Self::b}
    declare!{finish, Self::guard_1, Self::guard_2}
    /// if there are finish! functions
    declare!{updatable&lt;Z&gt;, Self::updatable_1}
    /// if there are no updatable functions
    declare!{non updatable}
}
<span class="boring">}
</span></code></pre></pre>
<p>The type <code>Z</code> above becomes bound for the updatable functions.</p>
<h2 id="dynamic-contracts"><a class="header" href="#dynamic-contracts">Dynamic Contracts</a></h2>
<p>Sapio also supports several &quot;Dynamic Contract&quot; paradigms which allows a user
to assemble contracts at run-time. The two main paradigms are accomplished by
either directly <code>impl AnyContract</code> or by using the <code>DynamicContract</code> struct
which holds all functions in vecs.</p>
<p>These are useful in rare circumstances.</p>
<h2 id="external-addresses"><a class="header" href="#external-addresses">External Addresses?</a></h2>
<p>The compiler is able to &quot;lift&quot; an address or a script into a contract via
<code>Object::from_address</code> and <code>Object::from_script</code>. Care should be taken when
doing so as Sapio will not be able to provide any further API data beyond such a bound.</p>
<h1 id="contract-compilation-overview"><a class="header" href="#contract-compilation-overview">Contract Compilation Overview</a></h1>
<p>When the compiler sees a new contract, it proceeds by processing each path
item one at a time. If the order of compilation is important for your contract:</p>
<ol>
<li>reconsider your priorities</li>
<li>repeat step 1</li>
<li>read the logic inside of the <code>Compilable::compile</code> function</li>
</ol>
<p>This logic may be improved over time to take advantage of parallelization or
otherwise restructure. As such, one should be careful when switching compiler
versions.</p>
<h2 id="determinism"><a class="header" href="#determinism">Determinism?</a></h2>
<p>Sapio is designed to be determinism-friendly. Repeated runs of the same
program should -- unless the user includes entropy -- return the same
results.</p>
<p>However, at writing, this property is not closely audited for, so outputs
should be treated as required to be stored in order to use a contract.</p>
<p>On the other hand, determinism means that for multi-party contracts being
generated in a Replicated state machine, if all parties have the same e.g.
WASM plugin, they can generate a contract definition and check that the
merkle root (in this case, a bitcoin address) is the same. If it differs,
either the arguments differed, someone cheated, or there was unexpected
non-determinism.</p>
<h1 id="sapio-for-fun-and-profit"><a class="header" href="#sapio-for-fun-and-profit">Sapio for Fun (and Profit)</a></h1>
<p>In this section, we're going to build a simple option contract. This sort of
contract could be used, for example, to make an on-chain asyncronous offer to
someone to enter a bet with you.</p>
<p>Then, you'll have some challenges to modify the contract to extend it's
functionality meaningfully.</p>
<p>The logic for the basic contract is as follows:</p>
<ol>
<li>If \(\tau_{now} &gt; \tau_{timeout} \):
<ul>
<li>send funds to return address</li>
</ul>
</li>
<li>If <code>strike_price</code> btc are added:
<ul>
<li>send funds + <code>strike_price</code> to strike_into contract</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Data Fields required to create a on-chain bet
pub struct UnderFundedExpiringOption {
    /// How much money has to be paid to strike the contract
    strike_price: Amount,
    /// if the contract expires, where to return the money
    return_address: bitcoin::Address,
    /// if the contract strikes, where to send the money
    strike_into: Box&lt;dyn Compilable&gt;,
    /// the timeout (as an absolute time) when the contract should end.
    timeout: AnyAbsTimeLock,
}

impl UnderFundedExpiringOption
{
    then! {
        /// return the funds on expiry
        fn expires(self, ctx) {
            Ok(Box::new(std::iter::once(
                ctx.template()
                    // set the timeout for this path -- because it is using
                    // then! we do not require a guard.
                    .set_lock_time(self.timeout)?
                    .add_output(
                        // ctx.funds() knows how much money has been sent to this contract
                        ctx.funds(),
                        // this bootstraps an address into a contract object
                        &amp;Compiled::from_address(self.return_address.clone(), None),
                        None,
                    )?
                    .into(),
            )))
        }
    }

    then! {
        /// continue the contract
        fn strikes(self, ctx) {
            let mut tmpl = ctx.template().add_amount(self.strike_price);
            tmpl.add_sequence()
                .add_output(
                    /// use the inner context of tmpl because it has added funds
                    (tmpl.ctx().funds() + self.strike_price).into(),
                    &amp;self.strike_into
                    None,
                )?
                .into()
        }
    }
}

impl Contract for UnderFundedExpiringOption
{
    declare!(then, Self::expires, Self::strikes);
    declare!(non updatable);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="challenges-1"><a class="header" href="#challenges-1">Challenges</a></h1>
<p>There's no right answer to the following challenges, and the resulting
contract may not be too useful, but it should be a good exercise to learn
more about writing Sapio contracts.</p>
<ol>
<li>Write a contract designed to be put into the <code>strike_into</code> field which
sends funds to one party or othe other based on a third-party revealing a
hash preimage <code>A</code> or <code>B</code>.</li>
<li>Modify the contract so that there is a <code>expire_A</code> and a <code>expire_B</code> path
that go to different addresses, and <code>expire_A</code> requires a signature or hash
reveal to be taken.</li>
<li>Modify the contract so that if <code>expire_A</code> is taken, a small payout
<code>early_exit_fee: bitcoin::Address</code> is made to a <code>early_exit : bitcoin::Address</code>.</li>
<li>Modify the contract so that <code>expire_A</code> is only present the fields required
by it are <code>Option::is_some</code> (hint: use <code>compile_if!</code>).</li>
<li>Add logic to deduct fees.</li>
<li>Add a <code>cooperative_close</code> <code>guard!</code> clause that allows both parties to exit gracefully</li>
</ol>
<h1 id="limitations-of-sapio"><a class="header" href="#limitations-of-sapio">Limitations of Sapio</a></h1>
<p>Sapio is rapidly maturing, but it is still early-days for bitcoin smart
contract compilers, and early-days for Sapio in particular. As such, one
should be careful to closely audit smart contracts designed with Sapio, be
careful to only use such contracts with trusted inputs, and in general take
precautions to ensure security of funds. As Sapio matures and we gain
confidence in smart contracts built with it, Sapio should be able to greatly
improve the security for many bitcoin users and applications.</p>
<p>Other than these general &quot;alpha software&quot; disclaimers, Sapio is designed with
certain upgrades to Bitcoin in mind that have not yet landed. While Sapio is
designed to work even without these upgrades, the functionality is severely
reduced or has a different security model.</p>
<p>This section goes over some of these limitations and when we might expect to
see them addressed.</p>
<h1 id="bip-119-emulation"><a class="header" href="#bip-119-emulation">BIP-119 Emulation</a></h1>
<p>Changes to Bitcoin take a long time. The star player in making Sapio work is
BIP-119, and that might take a while to get merged. To get around this, Sapio
provides some tools to enable similar functionality today by emulating
BIP-119 with signatures.</p>
<h2 id="the-default-emulator"><a class="header" href="#the-default-emulator">The Default Emulator</a></h2>
<p>Sapio CTV Emulators defines implementations of a local emualator that can be
used by sapio compiler library users. To use such an emulator, a user can
generate a seed and create a contract. After creating the contract and
binding it to a specific UTXO, a user should be able to delete the seed,
ensuring that only the compiled logic may be used. Alternatively, they can
retain the seed and promise not to improperly use it.</p>
<p>This crate also defines logic for servers that want to offer emulator
services to remote compilers. This is convenient since the emulator server
must be kept secure, so an organization may want it to be more tightly
safeguarded.</p>
<p>The emulator definitions include wrapper types that compose individual
instances of an emulator into a federated multisig. This is useful
for circumstances where a contract is between e.g. 2 parties and both
have a emulator server. Then the contract can be &quot;immutable&quot; unless
both collude.</p>
<p>To aid in experimentation, Judica, Inc operates a public emulator server for
regtest.</p>
<pre><code class="language-json">[
    &quot;tpubD6NzVbkrYhZ4Wf398td3H8YhWBsXx9Sxa4W3cQWkNW3N3DHSNB2qtPoUMXrA6JNaPxodQfRpoZNE5tGM9iZ4xfUEFRJEJvfs8W5paUagYCE&quot;,
    &quot;ctv.d31373.org:8367&quot;
]
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p><em>See the source code for more detailed documentation.</em></p>
<p>CheckTemplateVerify essentially functions as a self-signed transaction. I.e.,
imagine you could create a public key that could only ever sign a transaction
which matched a certain pattern?</p>
<p>To implement this functionality, we use BIP-32 HD keys with public derivation.</p>
<p>On initialization, a server picks a seed S and generates a root public key K
from it, and publishes K.</p>
<p>Users generate a transaction T and extract the CheckTemplateVerify hash H for
it. They then take H and convert it into a derivation path D of 8 u32's and 1
u8 for non-hardened derivation (see <code>hash_to_child_vec</code>).</p>
<p>This derivation path is then applied to K to generate a key C. This key is
added with a CheckSig(SIGHASH_ALL) to the script in place of a CTV clause.</p>
<p>Then, when a user desires to spend an output with such a key, they create the
entire transaction they want to occur and send it to the the emualtor server.</p>
<p>Without even checking to see that the key is used in the transaction, the
server generates the template hash H' (which should equal H) and then signs,
returning the signature to the client.</p>
<p>Before creating a contract, clients may wish to collect all possible
signatures required to prevent an availability fault.</p>
<p>This scheme has the benefit that:</p>
<ol>
<li>contract specification can occur without any online processes</li>
<li>The server has no intelligent logic, all guarantees are structural.</li>
<li>Server is completely stateless.</li>
<li>Availability/malfeasance can be controlled for with multisig</li>
<li>1:1 functionality mapping to CTV</li>
</ol>
<p>The downside of this approach to emulation is that:</p>
<ol>
<li>It is somewhat inefficient for scripts which have many branched possibilities.</li>
<li>No inherent mechanism to delete keys after use to protect against future exfiltration.</li>
</ol>
<h4 id="why-bip-32"><a class="header" href="#why-bip-32">Why BIP-32</a></h4>
<p>We use BIP-32 because it is a well studied primitive and derivation paths are
compatible with existing signing hardware. While it is true that a tweak of
32 bytes could be directly applied to the key more efficiently, easier
interoperability with existing tools seemed to be the best path.</p>
<h2 id="customizing-emulator-trait"><a class="header" href="#customizing-emulator-trait">Customizing Emulator Trait</a></h2>
<p>This emulator trait crate is a base that exports a trait definition and some
helper structs that are needed across the sapio ecosystem.</p>
<p>Defining the trait in its own crate allows us to use trait objects in our
compiler internals without needing to have the compiler directly depend on
e.g. networking primitives.</p>
<p>As a user of the Sapio library, you can define your own custom emulator logic
but that's out of scope of this book.</p>
<h2 id="future-work"><a class="header" href="#future-work">Future Work</a></h2>
<p><a href="https://github.com/sapio-lang/sapio/issues/100">There is a plan</a> to make
emulation more efficient based on Merkelization, but it is not yet
implemented because it messes with the current way the compiler works.</p>
<p>The efficiency issues are also solvable, more or less, with taproot.</p>
<h1 id="no-taproot"><a class="header" href="#no-taproot">No Taproot</a></h1>
<p>Currently Taproot is not active on Bitcoin and there is no deployment planned
for it.</p>
<p>Sapio scripts can become very large in size, and would greatly benefit from
being able to split up and merkelize the logic into smaller satisfiable
chunks. This makes it economical to use Sapio.</p>
<p>The compiler is currently relatively naive about this, and unknown (or worse,
unchecked) errors might occur as a result of pushing these limits. Hopefully,
<code>rust-miniscript</code> should catch such errors, but a malicious actor might be
able to trigger an unknown unsatisfiable script.</p>
<p>As such, Sapio is probably ill-advisable to use at writing, but this will
hopefully change in the future.</p>
<h2 id="emulation"><a class="header" href="#emulation">Emulation?</a></h2>
<p>In theory, Taproot could also be emulated in a similar manner to CTV. You
would run a server that would send a replacement key to use instead of the
Taproot key, and then the emulator would sign off on the transaction if the user
could provide a satisfaction.</p>
<p>Fortunately, it does seem that Taproot will be active within the next year,
so such measures are not yet required.</p>
<h2 id="taproot-optimizations"><a class="header" href="#taproot-optimizations">Taproot Optimizations</a></h2>
<p>With Taproot comes the opportunity to <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman
Code</a> spending paths to
decrease fees even further. Sapio currently uses <code>rust-miniscript</code> Policy
language to generate spending conditions, so Sapio should be able to carry
metadata from the programmer about the likelihood of various paths being
taken, but this currently only is used within a script as opposed to the
Tapscript tree itself.</p>
<h1 id="advanced-transaction-handling"><a class="header" href="#advanced-transaction-handling">Advanced Transaction Handling</a></h1>
<p>Sapio does not try to handle all possible types of Bitcoin transaction.</p>
<p>There are certain &quot;advanced techniques&quot; that have use cases, but are
difficult to reason about. For example, there are many ways that SIGHASH
flags can be exploited to create all sorts of possibilities. You can use
<code>OP_2DUP OP_SHA256 &lt;H1&gt; OP_EQUALVERIFY OP_SWAP OP_SHA256 &lt;H2&gt; OP_EQUALVERIFY OP_SIZE OP_SWAP OP_SIZE OP_EQUAL</code> (or something similar) to flip a fair coin between participants. There is a <em>lot</em>.</p>
<p>But Sapio doesn't make an effort to cleanly handle all possible contracts. It
makes an effort to address a safe and useful subset and make those contracts
well integrated with other standard software.</p>
<p>If you identify a killer use-case contract, please open an issue or a PR to
discuss the new functionality and how to add it.</p>
<h1 id="mempool--fees"><a class="header" href="#mempool--fees">Mempool &amp; Fees</a></h1>
<p>The Mempool is a treacherous place. If you're not familiar, the Mempool is
Bitcoin's backlog of unconfirmed transactions. It is a bounded queue which makes a best
effort at storing transactions that pay higher fees and dropping transactions which
pay insufficient fees.</p>
<p>The Mempool is an issue for a Sapio user because Sapio contracts are
generally immutable, which implies that Sapio contracts have to estimate the
minimum feerates at the time of contract creation.</p>
<p>For example, suppose I make a contract that has a state transition paying a
200 sats per vbyte feerate. And then by the time that transaction reaches the
mempool, it has gone up to 201 sats per vbyte minimum. Now I cannot easily
broadcast my transaction, and it is unlikely to wind up in a block.</p>
<p>There are many other ways that transactions can end up stuck.</p>
<p>Fortunately, there are some solutions to these sorts of problems, but none of
them are exactly &quot;easy&quot;. We'll divide them in three categories:</p>
<h1 id="careful-contract-programming"><a class="header" href="#careful-contract-programming">Careful Contract Programming</a></h1>
<p>Careful contract programming can ensure that:</p>
<ol>
<li>All contract transitions pay a high enough minimum we expect to be able to get into the mempool in the future</li>
<li>There are ways to inject &quot;gas inputs&quot; into the contract, if needed</li>
<li>There are ways to spend &quot;gas outputs&quot; from the contract just for Child-Pays-For-Parent logic.</li>
<li>Relative timelocks are used to prevent pinning attacks</li>
</ol>
<p>For a discussion of this topic with visuals, please see the Sapio Reckless VR
Talk section on fees:</p>
<p>TODO: Integrate this content into writing</p>
<ul>
<li><a href="https://diyhpl.us/wiki/transcripts/vr-bitcoin/2020-07-11-jeremy-rubin-sapio-101/">notes</a></li>
<li><a href="https://docs.google.com/presentation/d/1X4AGNXJ5yCeHRrf5sa9DarWfDyEkm6fFUlrcIRQtUw4/edit#slide=id.g8bddfc449f_0_358">slides</a></li>
<li><a href="https://youtu.be/4vDuttlImPc?t=1665">video</a></li>
</ul>
<div style="padding-bottom: 56.25%; position: relative;">
 <iframe style="position:absolute; top:0; left:0; width:100%; height: 100%;" src="https://www.youtube.com/embed/4vDuttlImPc?start=1665"
                                  frameborder="0" allow="accelerometer; autoplay; encrypted-media;
                                               gyroscope; picture-in-picture"
                                                  allowfullscreen></iframe>
</div>
<h1 id="p2p-networkmempool-policy-changes"><a class="header" href="#p2p-networkmempool-policy-changes">P2P Network/Mempool Policy Changes</a></h1>
<p>Package Relay is a proposed technique that is progressing for Bitcoin whereby
multiple transactions can be submitted in one bundle to show suitability for
the mempool. Therefore a contract leaf node might be able to demonstrate, by
spending the coin, that the contract interior nodes are worth mining.</p>
<p>However, this technique is limited insofar as contract interior nodes in
Sapio may commonly have relative time locks (or similar) which prevent the
mempool from considering dependents.</p>
<p>Package Relaying does, however, improve the function of intentional gas outputs.</p>
<h1 id="consensus-changes"><a class="header" href="#consensus-changes">Consensus Changes</a></h1>
<p>Consensus changes are very difficult to create, but it's possible that in the
future some set of consensus changes help decouple contract execution from fee paying.</p>
<p>For example, there is a
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html">proposal</a>
to replace Replace-By-Fee and Child-Pays-For-Parent with a mechanism that
functions as a virtual CPFP link. However, such proposals can introduce
subtle changes to Bitcoin's behavior and must be vetted closely.</p>
<h1 id="application-packaging"><a class="header" href="#application-packaging">Application Packaging</a></h1>
<h1 id="wasm"><a class="header" href="#wasm">WASM</a></h1>
<h1 id="rust-lib"><a class="header" href="#rust-lib">Rust Lib</a></h1>
<h1 id="tux"><a class="header" href="#tux">TUX</a></h1>
<h1 id="sapio-cli"><a class="header" href="#sapio-cli">Sapio CLI</a></h1>
<h1 id="advanced-rust-patterns"><a class="header" href="#advanced-rust-patterns">Advanced Rust Patterns</a></h1>
<p>Say it with me -- Sapio's Just Rust . Even though there's a lot of
additional paradigms and information to take in to use Sapio over normal Rust
programming, at the end of the day you can integrate Sapio into any Rust
paradigm you like.</p>
<p>That said, this section has a few useful patterns that merit specific mention
as you may find yourself reaching for them again and again.</p>
<h1 id="type-level-state-machines"><a class="header" href="#type-level-state-machines">Type Level State Machines</a></h1>
<p>In this example we use type level state machines to encode functionality that
is potentially available. See the example below for a sketch of how this can work.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The contract we're building, that can be in any type-state T.
struct StatefulContract&lt;T&gt;(PhantomData&lt;T&gt;);

/// We use empty structs as type tags.
/// Note: we could add a `trait State`, but it is not required
/// 
/// A contract can be in the open state or the closed state.
struct Opened;
struct Closed;

/// The &quot;state machine&quot; defines functionality that may be available
trait FunctionalityAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    then!{do_something}
}


/// Override the impl when state is Opened
impl FunctionalityAtState for StatefulContract&lt;Opened&gt; {
    then! {
        /// Transition from Opened =&gt; Closed state
        fn do_something(self, ctx) {
            ctx.template()
               .add_output(ctx.funds(),
                           &amp;StatefulContract::&lt;Closed&gt;(Default::default()),
                           None)?.into()
        }
    }
}

/// do not override `do_something`, no branch will be generated
impl FunctionalityAtState for StatefulContract&lt;Closed&gt; {}

/// Register that all StatefulContract&lt;T&gt;'s that implement FunctionalityAtState
/// are Contracts
impl Contract for StatefulContract&lt;T&gt;
where Self : FunctionalityAtState {
    declare!{then, Self::do_something}
}
<span class="boring">}
</span></code></pre></pre>
<p>This technique is <em>ridiculously</em> powerful. Imagine, for instance, that we
wanted to have different sorts of state other than Open and Closed. E.g., Red
and Green. We could then define Transition Rules that encode a graph like:</p>
<pre><code>(Open, Green) ==&gt; do_something ==&gt; (Closed, Green)
(Open, Red) ==&gt; do_something ==&gt; (Closed, Red)
(Open, Green) ==&gt; do_something_else ==&gt;  (Open, Red)
(Open, Red) ==&gt; do_something_else ==&gt; (Closed, Red)
</code></pre>
<p>using two separate <code>FunctionalityAtState</code> like traits:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The contract we're building, that can be in any type-state T.
struct StatefulContract&lt;T1, T2&gt;(PhantomData&lt;(T1, T2)&gt;);

/// We use empty structs as type tags.
/// Note: we could add a `trait State`, but it is not required
/// 
/// A contract can be in the open state or the closed state.
struct Opened;
struct Closed;
// And Red or Green
struct Red;
struct Green;

/// The &quot;state machine&quot; defines functionality that may be available
trait OpenAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    then!{do_something}
}

trait ColorAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    then!{do_something}
}


/// Override the impl when state is Opened
impl OpenAtState&lt;DontCare&gt; for StatefulContract&lt;Opened, DontCare&gt; {
    then! {
        /// Transition from Opened =&gt; Closed state
        fn do_something(self, ctx) {
            ctx.template()
               .add_output(ctx.funds(),
                           &amp;StatefulContract::&lt;Closed, DontCare&gt;(Default::default()),
                           None)?.into()
        }
    }
}

/// do not override `do_something`, no branch will be generated
impl OpenAtState&lt;DontCare&gt; for StatefulContract&lt;Closed, DontCare&gt; {}

/// Override the impl when state is Opened
impl ColorAtState for StatefulContract&lt;Open, Green&gt; {
    then! {
        /// Transition from Green =&gt; Red state
        fn do_something_else(self, ctx) {
            ctx.template()
               .add_output(ctx.funds(),
                           &amp;StatefulContract::&lt;Open, Red&gt;(Default::default()),
                           None)?.into()
        }
    }
}

impl ColorAtState for StatefulContract&lt;Open, Red&gt; {
    then! {
        /// Transition from Open =&gt; Closed state
        fn do_something_else(self, ctx) {
            ctx.template()
               .add_output(ctx.funds(),
                           &amp;StatefulContract::&lt;Closed, Red&gt;(Default::default()),
                           None)?.into()
        }
    }
}

/// do not override `do_something_else`, no branch will be generated
impl ColorAtState&lt;DontCare&gt; for StatefulContract&lt;DontCare, Red&gt; {}

/// Register that all StatefulContract&lt;T&gt;'s that implement OpenAtState
/// are Contracts
impl Contract for StatefulContract&lt;T&gt;
where Self : OpenAtState + ColorAtState {
    declare!{then, Self::do_something, Self::do_something_else}
}
<span class="boring">}
</span></code></pre></pre>
<p>This technique showcases how Sapio could encode very sophisticated logic in
program generation.</p>
<p>It's also notable that following rustc v1.51, it is possible to use <code>const</code>'s
as generic type parameters which enables even more computation at the type level.</p>
<h1 id="tryfrom-constructors"><a class="header" href="#tryfrom-constructors">TryFrom Constructors</a></h1>
<p>Often times we want to assure that various properties must be true about the
arguments passed to a contract instance.</p>
<p>By using TryFrom and being careful with the visibility of inner fields it is
possible to guarantee that the only way to get an X is by going through type
Y.</p>
<p>This can be bound using the <code>serde(try_from)</code> attribute, which makes it so
that any deserialization of <code>X</code> first passes through <code>Y</code>. This is
particularly useful when <code>X</code> contains types (such as function pointers or
caches) that cannot be deserialized, but we want to provide a way for a third
party to pass JSON args to construct an <code>X</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;
use std::convert::TryInto;
use serde::*;
/// inner argument not pub, X cannot be constructed without going through Y
#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(try_from=&quot;Y&quot;)]
pub struct X(u32);

#[derive(Serialize, Deserialize, JsonSchema)]
pub struct Y(pub u32);
impl TryFrom&lt;Y&gt; for X {
    type Error = &amp;'static str;
    fn try_from(y: Y) -&gt; Result&lt;Self, Self::Error&gt; {
        if y.0 &lt; 10 {
            Err(&quot;Too Small I Guess?&quot;)
        } else {
            Ok(X(y.0))
        }
    }
}

let x: X = Y(10).try_into().unwrap();

<span class="boring">}
</span></code></pre></pre>
<h1 id="concrete-wrappers"><a class="header" href="#concrete-wrappers">Concrete Wrappers</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
