<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Designing Bitcoin Contracts with Sapio</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Sapio Language</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">ABC 123</li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installing Sapio</a></li><li class="chapter-item expanded "><a href="ch01-02-learn-rust.html"><strong aria-hidden="true">1.2.</strong> Learning Rust</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-world.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-bip-119.html"><strong aria-hidden="true">2.</strong> BIP-119 CTV Fundamentals</a></li><li class="chapter-item expanded "><a href="ch03-00-basics.html"><strong aria-hidden="true">3.</strong> Sapio Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-guts.html"><strong aria-hidden="true">3.1.</strong> Contract Guts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-miniscript.html"><strong aria-hidden="true">3.1.1.</strong> Miniscript/Policy</a></li><li class="chapter-item expanded "><a href="ch03-01-builder.html"><strong aria-hidden="true">3.1.2.</strong> Template Builder</a></li><li class="chapter-item expanded "><a href="ch03-01-timelocks.html"><strong aria-hidden="true">3.1.3.</strong> Time Locks</a></li><li class="chapter-item expanded "><a href="ch03-01-amounts.html"><strong aria-hidden="true">3.1.4.</strong> Sats and Coins</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-02-guts.html"><strong aria-hidden="true">3.2.</strong> Contract Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-02-guard.html"><strong aria-hidden="true">3.2.1.</strong> guard</a></li><li class="chapter-item expanded "><a href="ch03-02-compile_if.html"><strong aria-hidden="true">3.2.2.</strong> compile_if</a></li><li class="chapter-item expanded "><a href="ch03-02-then.html"><strong aria-hidden="true">3.2.3.</strong> then</a></li><li class="chapter-item expanded "><a href="ch03-02-finish.html"><strong aria-hidden="true">3.2.4.</strong> continuation</a></li><li class="chapter-item expanded "><a href="ch03-02-when-use-macros.html"><strong aria-hidden="true">3.2.5.</strong> When to use macros?</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-03-declarations.html"><strong aria-hidden="true">3.3.</strong> Contract Declarations</a></li><li class="chapter-item expanded "><a href="ch03-04-compliation.html"><strong aria-hidden="true">3.4.</strong> Contract Compilation Overview</a></li><li class="chapter-item expanded "><a href="ch03-04-continuation-effects.html"><strong aria-hidden="true">3.5.</strong> Contract Continuation Effects</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Exercises</li><li class="chapter-item expanded "><a href="ch04-00-sapio-fun-profit.html"><strong aria-hidden="true">4.</strong> Sapio for Fun (and Profit)</a></li><li class="chapter-item expanded affix "><li class="part-title">Warnings</li><li class="chapter-item expanded "><a href="ch05-00-limitations.html"><strong aria-hidden="true">5.</strong> Limitations of Sapio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ctv-emulator.html"><strong aria-hidden="true">5.1.</strong> BIP-119 Emulation</a></li><li class="chapter-item expanded "><a href="ch05-02-taproot.html"><strong aria-hidden="true">5.2.</strong> Taproot Support</a></li><li class="chapter-item expanded "><a href="ch05-03-txns.html"><strong aria-hidden="true">5.3.</strong> Advanced Transaction Handling</a></li><li class="chapter-item expanded "><a href="ch05-04-gas.html"><strong aria-hidden="true">5.4.</strong> Mempool &amp; Fees</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="ch06-00-packaging.html"><strong aria-hidden="true">6.</strong> Application Packaging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-wasm.html"><strong aria-hidden="true">6.1.</strong> WASM</a></li><li class="chapter-item expanded "><a href="ch06-02-rust.html"><strong aria-hidden="true">6.2.</strong> Rust Lib/Bin</a></li><li class="chapter-item expanded "><a href="ch06-02-studio.html"><strong aria-hidden="true">6.3.</strong> Sapio Studio</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-cli.html"><strong aria-hidden="true">7.</strong> Sapio CLI</a></li><li class="chapter-item expanded "><a href="ch08-00-useful-rust.html"><strong aria-hidden="true">8.</strong> Advanced Rust Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-state-machines.html"><strong aria-hidden="true">8.1.</strong> Type Level State Machines</a></li><li class="chapter-item expanded "><a href="ch08-02-tryfrom.html"><strong aria-hidden="true">8.2.</strong> TryFrom Constructors</a></li><li class="chapter-item expanded "><a href="ch08-03-concrete.html"><strong aria-hidden="true">8.3.</strong> Concrete &amp; Generic Types</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Designing Bitcoin Contracts with Sapio</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/sapio-lang/sapio" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="https://github.com/sapio-lang/sapio/raw/master/.github/logo.png" alt="" /></p>
<h2 id="designing-bitcoin-contracts-with-sapio"><a class="header" href="#designing-bitcoin-contracts-with-sapio">Designing Bitcoin Contracts with Sapio</a></h2>
<p><a href="https://github.com/sapio-lang/sapio/actions?query=branch%3Amaster"><img src="https://github.com/sapio-lang/sapio/workflows/Continuous%20integration/badge.svg" alt="Build Status" /></a> <a href="https://crates.io/crates/sapio"><img src="https://img.shields.io/crates/dv/sapio" alt="crates" /></a> <a href="https://docs.rs/sapio"><img src="https://img.shields.io/docsrs/sapio/latest" alt="docs" /></a> <a href="https://github.com/sapio-lang/sapio/fork"><img src="https://img.shields.io/github/forks/sapio-lang/sapio?label=Fork%20Me&amp;style=social" alt="forkme" /></a> </p>
<p><em>A practical guide to engineering bitcoin smart contracts using the Sapio Language.</em></p>
<p>This book is a work in progress! Please <a href="https://github.com/sapio-lang/sapio">submit a PR</a> with
improvements or suggestions.</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em>Designing Bitcoin Contracts with Sapio</em>, the official manual and
best starting place to learn how to make Smart Contracts for Bitcoin. Sapio
is an in-development tool that empowers Bitcoin Developers to craft smart
contracts in an intuitive, safe, and composable way. Sapio challenges the
notion that you can't make complex smart contracts for Bitcoin, and opens the
floodgates for a myriad of new ideas to be defined easily.</p>
<h2 id="who-is-sapio-for"><a class="header" href="#who-is-sapio-for">Who is Sapio For?</a></h2>
<p>Sapio is for anyone who wants to build with Bitcoin. That spans students
demonstrating research concepts, corporations working on custody solutions,
and developers improving open source solutions. Sapio is not a Solidity
equivalent. The programming model is <em>very</em> different. But it does help
anyone trying to solve a transactional protocol for Bitcoin solve it
elegantly.</p>
<p>Sapio is currently alpha quality software. You should think very carefully
before using Sapio with any real money. There will be kinks to untwist,
wrinkles to iron out, and bugs to squash. Hopefully you, dear reader, will
even be able to help with that! Sapio is not -- at present -- for the faint
of heart.</p>
<h2 id="what-will-i-learn-if-i-read-this-book"><a class="header" href="#what-will-i-learn-if-i-read-this-book">What will I learn if I read this book?</a></h2>
<p>This book is intended to teach you how to think about programming Sapio
contracts. The book contains some exercises (that are heavily encouraged)
that should instigate your understanding of how to build smart contracts
for Bitcoin.</p>
<p>If you go through the chapters in order and complete all the exercises you
should develop a firm grasp of how to use Sapio, how it works, and how it
will progress over time. You will also have sufficient understanding to
contribute back meaningfully to the open source project.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let's start buil... not so fast there.</p>
<p>Before we get into it, we need to cover some basics:</p>
<ul>
<li>Setting up an environment</li>
<li>Learning Rust</li>
<li>Hello World contract</li>
</ul>
<h1 id="installing-sapio"><a class="header" href="#installing-sapio">Installing Sapio</a></h1>
<h2 id="sapio-pod-quickstart"><a class="header" href="#sapio-pod-quickstart">Sapio Pod QuickStart:</a></h2>
<p><a href="https://hub.docker.com/repository/docker/sapiolang/sapio"><strong>DOWNLOAD THE POD</strong></a></p>
<p>Today, Sapio can come to you in an easy to set up Docker compatible container
(unofficial™). With the Sapio pod you get:</p>
<ol>
<li>A CTV Compatible Bitcoin Node running regtest</li>
<li>Rust</li>
<li>A pre-built cached Sapio Directory for you to use as a workspace</li>
<li>sapio-cli pre-built</li>
<li>Sapio Studio built and running over X11 connected to your regtest node</li>
<li>neovim for editing</li>
</ol>
<p>See <a href="https://github.com/jeremyrubin/sapio-pod">the repo</a> for setup instructions,
especially with x11 through containerization.</p>
<p>This  is the simplest way to get a working Sapio playground, but you may prefer
to have it set up locally (x11 can be glitchy). The Sapio Pod is currently
targetted at someone wanting a pain free development environment for tutorials,
but future releases may target more specific needs such as deployments in
infrastructure.</p>
<p>The book will <em>assume</em> this is your setup, and instructions will be tailored
appropriately.</p>
<h2 id="local-quickstart"><a class="header" href="#local-quickstart">Local QuickStart:</a></h2>
<p>Sapio should work on all platforms, but is recommended for use with Linux (Ubuntu preferred).
Follow this quickstart guide to get going.</p>
<ol>
<li>Get <a href="https://rustup.rs/">rust</a> if you don't have it already.</li>
<li>Add the wasm target and nightly toolchain by running the below command in your terminal:</li>
</ol>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<blockquote>
<p>Tip: On macOS you may need to do the following:</p>
</blockquote>
<blockquote>
<pre><code class="language-bash">brew install llvm
cargo install wasm-pack
rustup toolchain install nightly
rustup default nightly
</code></pre>
<p>and then load the following before compiling to use the newer llvm/clang.</p>
<pre><code class="language-bash">export PATH=&quot;/opt/homebrew/opt/llvm/bin:$PATH&quot;
# for older homebrew installs
# export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;
export CC=/opt/homebrew/opt/llvm/bin/clang
export AR=/opt/homebrew/opt/llvm/bin/llvm-ar
</code></pre>
</blockquote>
<ol start="3">
<li>Clone this repo: </li>
</ol>
<pre><code>git clone --depth 1 git@github.com:sapio-lang/sapio.git &amp;&amp; cd sapio
</code></pre>
<p>We recommend a shallow clone unless you want the full history.</p>
<ol start="4">
<li>Build a plugin</li>
</ol>
<pre><code>cd plugin-example/ &amp;&amp; cargo build --release --target wasm32-unknown-unknown &amp;&amp; cd ..
</code></pre>
<p>If the compilation fails, you may want to check the clang version (8&lt;=), and install libraries for cross-compilation (in case of ubuntu, <code>sudo apt install gcc-multilib</code>)</p>
<ol start="5">
<li>Instantiate a contract from the plugin:</li>
</ol>
<pre><code>cargo run --bin sapio-cli -- contract create &quot;{\&quot;arguments\&quot;:{\&quot;ForAddress\&quot;:{\&quot;amount_step\&quot;:{\&quot;Sats\&quot;:100},\&quot;cold_storage\&quot;:\&quot;bcrt1qumrrqgt7e3a7damzm8x97m6sjs20u8hjw2hcjj\&quot;,\&quot;hot_storage\&quot;:\&quot;bcrt1qumrrqgt7e3a7damzm8x97m6sjs20u8hjw2hcjj\&quot;,\&quot;mature\&quot;:{\&quot;RH\&quot;:10},\&quot;n_steps\&quot;:10,\&quot;timeout\&quot;:{\&quot;RH\&quot;:5}}},\&quot;context\&quot;:{\&quot;amount\&quot;:1,\&quot;network\&quot;:\&quot;Regtest\&quot;}}&quot; --file=&quot;plugin-example/target/wasm32-unknown-unknown/debug/sapio_wasm_vault.wasm&quot;
</code></pre>
<p>You can use <code>cargo run --release --bin sapio-cli -- help</code> to learn more about what a the
CLI can do! and <code>cargo run --bin sapio-cli -- &lt;subcommand&gt; help</code> to learn about
subcommands like <code>contract</code>. If you aren't modifying Sapio itself, you'll want
to run <code>cargo build --release</code> and use a release binary as it is much faster.</p>
<ol start="6">
<li>Install Sapio Studio</li>
</ol>
<p><a href="https://github.com/sapio-lang/sapio-studio">Sapio Studio</a> is an in-development
graphical user interface for Sapio. It is the recommended way to get started with Sapio development.
We recommend a shallow clone unless you want the full history.</p>
<pre><code>git clone --depth 1 git@github.com:sapio-lang/sapio-studio.git &amp;&amp; cd sapio-studio
yarn install
</code></pre>
<p>and then in separate shells</p>
<pre><code>yarn start-react
yarn start-electron
</code></pre>
<p>The first time you run it you most likely <em>will</em> have some errors, you will need
to ensure you've configured your client correctly. You can do this by opening
the Preferences menu and configuring it appropriately. Soon there will be a better
interface for first run setup.</p>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<p>You can review the docs either by building them locally or viewing
<a href="https://docs.rs/sapio">online</a>.</p>
<h1 id="learning-rust"><a class="header" href="#learning-rust">Learning Rust</a></h1>
<p>A full rust tutorial is out of scope for this guide.</p>
<p>You may wish to begin with <a href="https://doc.rust-lang.org/book/">The Rust Programming
Language</a>.</p>
<p>Deep expertise in Rust is not <em>required</em> to be a fluent Sapio developer, but it
helps. Typical Sapio programs are relatively simple as we are not typically
concerned with concurrency or memory efficiency.</p>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's get going with your very first hello world contract!</p>
<p>Unfortunately, until Sapio becomes a little more popular the embedded rust
playground won't work, so you'll want to copy it locally.</p>
<p>We're going to start with a contract that allows two parties, Alice and Bob,
to either agree on an outcome or to default to a pre-fixed outcome after a
relative timeout.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JsonSchema, Deserialize)]
pub struct TrustlessEscrow {
    alice: bitcoin::PublicKey,
    bob: bitcoin::PublicKey,
    alice_escrow_address: bitcoin::Address,
    alice_escrow_amount: CoinAmount,
    bob_escrow_address: bitcoin::Address,
    bob_escrow_amount: CoinAmount,
}

impl TrustlessEscrow {
    #[guard]
    fn cooperate(self, _ctx: Context) {
        Clause::And(vec![Clause::Key(self.alice), Clause::Key(self.bob)])
    }
    #[then]
    fn use_escrow(self, ctx: Context) {
        ctx.template()
            .add_output(
                self.alice_escrow_amount.try_into()?,
                &amp;Compiled::from_address(self.alice_escrow_address.clone(), None),
                None,
            )?
            .add_output(
                self.bob_escrow_amount.try_into()?,
                &amp;Compiled::from_address(self.bob_escrow_address.clone(), None),
                None,
            )?
            .set_sequence(
                0,
                RelTime::try_from(std::time::Duration::from_secs(10 * 24 * 60 * 60))?.into(),
            )?
            .into()
    }
}

impl Contract for TrustlessEscrow {
    declare! {finish, Self::cooperate}
    declare! {then, Self::use_escrow}
    declare! {non updatable}
}

REGISTER![TrustlessEscrow, &quot;logo.png&quot;];

<span class="boring">}
</span></code></pre></pre>
<p>Navigate to <code>sapio/plugin-example/helloworld/plugin.rs</code> in your code editor.
You'll find this code there. You should be able to compile it using 
<code>cargo build --target wasm32-unknown-unknown</code>. </p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<p>For the challenges, you'll want to modify the helloworld plugin file directly.
Through this tutorial we'll use this as a sandbox file.</p>
<ol>
<li>Add a new finish state that allows Alice to spend after a relative timeout.</li>
<li>Add <code>use_escrow2</code> which enables a different pair of payouts to Alice and
Bob as an alternative.</li>
</ol>
<h1 id="bip-119-ctv-fundamentals"><a class="header" href="#bip-119-ctv-fundamentals">BIP-119 CTV Fundamentals</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>BIP-119 OP_CHECKTEMPLATEVERIFY (CTV) is a
<a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki">proposed</a>
soft-fork upgrade to Bitcoin for enabling a bevy of use cases.</p>
<p>At it's core, CTV enables a script to commit to the &quot;important bits&quot; of how it can be spent, or the:</p>
<ol>
<li>nVersion</li>
<li>nLockTime</li>
<li>scriptSig hash (maybe!)</li>
<li>input count</li>
<li>sequences hash</li>
<li>output count</li>
<li>outputs hash</li>
<li>input index</li>
</ol>
<p>This enables a myriad of use cases, which are described in detail in the
<a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki">BIP</a> and on
the website <a href="https://utxos.org">utxos.org</a>.</p>
<h2 id="how-do-we-think-about-smart-contracts-and-ctv"><a class="header" href="#how-do-we-think-about-smart-contracts-and-ctv">How do we think about Smart Contracts and CTV?</a></h2>
<p>Before CTV, in most Bitcoin smart contracts, we think at the key-level. That
is, what is a complex set of signers and satisfactions to unlock a specific
coin. But once we unlock a coin, the smart contract usually does not encode
any further restrictions on how it may be spent.</p>
<p>You could think of this as &quot;a key to a car&quot;. If it unlocks the car, you can
take the car wherever you want.</p>
<p>With CTV, we hope to encode a bit more information about how coins should
move by providing the paths that the coins must move through as well. So
rather than just being the key to a car, you could think of it a bit more
like the keys to train -- still required to start the engine, but you have to
stay on the tracks and there is a finite number of tracks to pick at any
juncture.</p>
<p>That's all a bit abstract. Think back to the Hello World example we saw earlier. We
created a coin with the following options:</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout \( \rightarrow \) coins go back to Alice and Bob</li>
</ol>
<p>Now imagine we wanted to change the rules a little. What if instead of rule 2
apply after a timeout, what if we wanted the timeout to be measured <em>from the
time that Alice or Bob claimed they wanted to use the escrow</em>.</p>
<p>This puts us in a little bit of a pickle. Sure we could just re-write the rules:</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout <em>since Alice or Bob requested</em> \( \rightarrow \) coins go back to Alice and Bob</li>
</ol>
<p>But Bitcoin doesn't have a script level notion of &quot;since&quot; a part of a witness was constructed. The CTV way to think of this script is to define a state machine with two states \( S \in \{Normal, Closing\}\) and the rules:</p>
<ul>
<li>
<p>\( S \gets Normal\):</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Alice or Bob Requested \( \rightarrow \) (\(S \gets Closing \))</li>
</ol>
</li>
<li>
<p>\( S \gets Closing\):</p>
<ol>
<li>Alice and Bob Agree \( \rightarrow \) coin goes anywhere</li>
<li>Timeout <em>since</em> (\(S \gets Closing\)) \( \rightarrow \) coins go back to Alice and Bob.</li>
</ol>
</li>
</ul>
<p>What drives the transition from Normal to Closing? Just a standard Bitcoin transaction!</p>
<h2 id="so-what-is-sapio"><a class="header" href="#so-what-is-sapio">So What is Sapio</a></h2>
<p>Sapio is an embedded domain specific language for defining these sorts of
state transition rules to build smart contracts for Bitcoin.</p>
<p>CTV is used as the mechanism to enforce that specific state transitions occur.</p>
<p>When we <strong>write</strong> a program in Sapio, we are designing an <em>arbitrary</em> state
machine that can run any program.</p>
<p>When we <strong>compile</strong> a Sapio program, we run that state machine to completion and merkelize the resultant program states into a fixed graph.</p>
<p>As such, Sapio is a very powerful framework for designing Bitcoin smart contracts, but we're constrained to the set of contracts where we can enumerate all possible end states.</p>
<p>To get around these restrictions, Sapio has some tricks up it's sleeve that
will be described in future chapters.</p>
<h1 id="sapio-basics"><a class="header" href="#sapio-basics">Sapio Basics</a></h1>
<p>This section is intended to introduce the basic components of Sapio and how
they are used. It's a nice complement to the material available in the
<a href="https://docs.rs/sapio">online docs</a>, which are more targeted to everyday users.</p>
<h1 id="contract-guts"><a class="header" href="#contract-guts">Contract Guts</a></h1>
<p>This section covers basic modules and primitives that are handy to know as
you navigate Sapio contracts.</p>
<p>Feel free to skip this section and refer back to it as needed!</p>
<h1 id="miniscript--policy"><a class="header" href="#miniscript--policy">Miniscript &amp; Policy</a></h1>
<p>Miniscript &amp; Policy are tools for creating well formed Bitcoin scripts developed
by Blockstream developers Pieter Wiulle, Andrew Poelstra, and Sanket Kanjalkar.</p>
<p>From the <a href="http://bitcoin.sipa.be/miniscript/">miniscript website</a>:</p>
<blockquote>
<p>Miniscript is a language for writing (a subset of) Bitcoin Scripts in a
structured way, enabling analysis, composition, generic signing and more.</p>
<p>Bitcoin Script is an unusual stack-based language with many edge cases,
designed for implementing spending conditions consisting of various
combinations of signatures, hash locks, and time locks. Yet despite being
limited in functionality it is still highly nontrivial to:</p>
<ol>
<li>Given a combination of spending conditions, finding the most economical script to implement it.</li>
<li>Given two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the &quot;keys&quot; is another multisig).</li>
<li>Given a script, find out what spending conditions it permits.</li>
<li>Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.</li>
<li>Given a script, be able to predict the cost of spending an output.</li>
<li>Given a script, know whether particular resource limitations like the ops limit might be hit when spending.</li>
</ol>
<p>Miniscript functions as a representation for scripts that makes these sort of
operations possible. It has a structure that allows composition. It is very
easy to statically analyze for various properties (spending conditions,
correctness, security properties, malleability, ...). It can be targeted by
spending policy compilers (see below). Finally, compatible scripts can easily
be converted to Miniscript form - avoiding the need for additional metadata
for e.g. signing devices that support it.</p>
</blockquote>
<p>For Sapio, we use a customized
<a href="https://github.com/sapio-lang/rust-miniscript">fork of rust-miniscript</a> library
which extends miniscript with functionality relevant to CheckTemplateVerify and
Sapio. All changes should be able to be upstreamed... eventually.</p>
<p>The Policy type (named Clause in Sapio) allows us to specify the predicates upon
which various state transitions should unlock.</p>
<p>This makes it so that Sapio should be compatible with other software that can
generate valid Policies, and compatible with PSBT signing devices that
understand how to satisfy miniscripts.</p>
<p>A limitation of this approach is that there are certain types of script which
are possible, but not yet supported in Sapio. For example, the <code>OP_SIZE</code> coin
flip script is not currently possible with Miniscript. Another limitation of
Miniscript is that keys may not be repeated to preserve a guarantee of non
malleability.</p>
<p>Miniscript &amp; Policy are an ongoing research concern. As they develop, Sapio will
benefit from this foundational work.</p>
<h1 id="template-builder"><a class="header" href="#template-builder">Template Builder</a></h1>
<p>The Template builder is one of the most important parts of a Sapio contract.
It is how you define and build a transaction step.</p>
<p>It's also an area of active work to improve the UX of, to enable building new
kinds of smart contracts more easily, supporting more advanced constructs.</p>
<p>The below code demonstrates how to use the template builder. See the
<a href="https://docs.rs/sapio/0.1.2/sapio/template/builder/struct.Builder.html">docs</a>
for more details!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X;
impl X {
    #[then]
    fn example(self, ctx: Context) {
        /// create a new template with the current context
        /// and set lock time to height 100
        let mut tmpl = ctx.template().set_lock_time(AbsHeight::from(100).into())?;
        let h = vec![(String::from(&quot;Metadata&quot;), String::from(&quot;IS_COOL&quot;))].into_iter().collect();
        /// Add an output
        /// make sure to assign to update after initial assignment, otherwise tmpl is consumed completely...
        /// Note: What happens when X creates an X (infinite loop)
        tmpl = tmpl.add_output(bitcoin::Amount::from_sat(1000), &amp;X, Some(h))?;
        /// mark some funds unavailable (e.g. fees)
        tmpl = tmpl.spend_amount(bitcoin::Amount::from_sat(0xFEE))?;
        /// note that tmpl has it's own clone of ctx, which we should be
        /// careful to use instead of the passed in ctx, which is immutable
        if tmpl.ctx().funds() &lt; bitcoin::Amount::from_sat(100000) {
            return Err(CompilationError::TerminateCompilation);
        }
        /// certain metadata is inteded to be &quot;non-proprietary&quot; and has dedicated setters
        tmpl = tmpl.set_label(&quot;Example!&quot;.into());
        /// adds a new _input_ and sets it sequence to relheight 1 block.
        tmpl = tmpl.add_sequence().set_sequence(-1, RelHeight::from(1))?;
        /// add some additional funds (i.e. from the input we just added)
        tmpl = tmpl.add_amount(Bitcoin::from_sats(10000));
        /// Send the remaining funds to this output
        tmpl = tmpl.add_output(tmpl.ctx().funds(), &amp;X, None)?;
        let feeling_lazy = true;
        if feeling_lazy {
            /// This finishes the builder and turns it into the correct result type
            tmpl.into()
        } else {
            /// equivalently, but more verbosely
            Ok(Box::new(std::iter::once(Template::from(tmpl))))
        }
    }
    }
impl Contract for X {
    /*...*/
}

<span class="boring">}
</span></code></pre></pre>
<p>The Sapio model currently expects that all contracts UTXO spends are located
in the first input. The CTV hash commits to this, so it cannot be modified at
this time (but future work might allow changing this).</p>
<h1 id="time-locks"><a class="header" href="#time-locks">Time Locks</a></h1>
<p>Sapio provides some utilities for working with both relative and absolute timelocks. See <a href="https://docs.rs/sapio-base/0.1.0/sapio_base/timelocks/index.html">the sapio-base docs</a> for more details.</p>
<p>The Time Lock Utilities have some nice interfaces for dealing with timelocks generically and converting them into Policy Clauses.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use sapio_base::timelocks::*;
use std::time::Duration;

AbsHeight::try_from(800_000u32);
AbsTime::try_from(1_000_000_000u32);
AbsTime::try_from(Duration::from_secs(1_000_000_000u64));
// chunks of 512 seconds
RelTime::from(10u16);
RelTime::try_from(Duration::from_secs(10*512));
RelHeight::from(20u16);


// Correctly compiles into Clause::Older
let c: Clause = RelHeight::from(20u16).into();

let a: AnyRelTimeLock = RelHeight::from(20u16).into();
let b: AnyTimeLock = RelHeight::from(20u16).into();

<span class="boring">}
</span></code></pre></pre>
<p>These are not required to be used, but care should be taken if not used to
ensure that correct values are passed to the miniscript compiler since
Miniscript doesn't validate these strictly.</p>
<h1 id="sats-and-coins"><a class="header" href="#sats-and-coins">Sats and Coins</a></h1>
<p>There are several different ways of expressing amounts in Sapio.</p>
<p>That there isn't a single canonical way to represent amounts is unfortunate,
and hopefully these types can be fully unified in the future. But it's a
problem for good reason.</p>
<h2 id="a-brief-rant"><a class="header" href="#a-brief-rant">A brief rant</a></h2>
<p>Suppose I tell you to send 10 to Alice. Is that 10 sats? or 10 bitcoin? You
might think that 10.0 would be unambiguous, but it turns out the lightning
network is building sub-satoshi support.</p>
<p>The <em>only</em> way to make context-free unambiguous amounts is to have them
explicitly tagged, e.g., {denom: &quot;sats&quot;, amount: 10}.</p>
<p>This would be great, but there are already myriads of services out there
where the only way to know what unit you have is to RTFM.</p>
<p>Generally, we know that floating point representations are evil for financial
transactions, but because we want to be compatible with JSON/Javascript, we
don't quite have a choice. Fortunately, 21e6 Bitcoin with 8 places fit
exactly into floats without loss. However, bets are off when doing arithmetic
with such values.</p>
<p>A last wrinkle: Bitcoin's amount type is a signed integer. Rust-bitcoin uses an Unsigned integer. So in theory there are unrepresentable amounts we're happy to work with. Great.</p>
<h2 id="its-up-to-every-programmer"><a class="header" href="#its-up-to-every-programmer">It's up to every programmer</a></h2>
<p>Therefore, to get amounts right is a task that is up to the programmer
largely to get this right. There are a few different amount types to be aware
of.</p>
<ol>
<li>u64 represents sats. may be too big!</li>
<li>i64 represents sats. may be too small!</li>
<li><code>bitcoin::Amount</code> represents u64, no standard serialization.</li>
<li><code>bitcoin::SignedAmount</code> represents i64, no standard serialization.</li>
<li><code>bitcoin::CoinAmount</code> standard tagged serialization, either u64 or f64.</li>
</ol>
<p>These different types have uses in different circumstances.</p>
<p>Because <code>bitcoin::Amount</code> does not have a standard serializer, in order to
use it in e.g. a <code>Vec</code>, you have to wrap the type with a serializer. <code>From</code> impls can make life a little easier to work with these.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitcoin::util::amount::Amount;

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// A wrapper around `bitcoin::Amount` to force it to serialize with f64.
#[derive(
    Serialize, Deserialize, JsonSchema, Clone, Copy, Debug, Ord, PartialOrd, PartialEq, Eq,
)]
#[serde(transparent)]
struct AmountF64(
    #[schemars(with = &quot;f64&quot;)]
    #[serde(with = &quot;bitcoin::util::amount::serde::as_btc&quot;)]
    Amount,
);

impl From&lt;Amount&gt; for AmountF64 {
    fn from(a: Amount) -&gt; AmountF64 {
        AmountF64(a)
    }
}
impl From&lt;AmountF64&gt; for Amount {
    fn from(a: AmountF64) -&gt; Amount {
        a.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>CoinAmount</code> does not have this problem, but it can't be used in all
contexts, e.g. external APIs that aren't tagged.</p>
<h2 id="dont-panic-or-do"><a class="header" href="#dont-panic-or-do">Don't Panic (or do)</a></h2>
<p>A final annoyance is that <code>bitcoin::Amount</code> has arithmetic that may panic
(unless you use the <code>checked_</code> variants). So one must be careful to ensure
that any set of values passed in are safe to add.</p>
<p>Sapio currently does not do a fantastic job of this, but that can be improved
in the future.</p>
<h1 id="contract-actions"><a class="header" href="#contract-actions">Contract Actions</a></h1>
<p>Contracts have a variety of different actions used at different times.</p>
<table><thead><tr><th>name</th><th>function</th></tr></thead><tbody>
<tr><td>guard</td><td>Create a clause using miniscript with access to the contract's values and context.</td></tr>
<tr><td>compile_if</td><td>Determine if a <code>then</code> or <code>finish</code> should be compiled based on the contract's values and context</td></tr>
<tr><td>then</td><td>Create a path or paths  that are guaranteed using CTV for a contract to be spent,  with optional <code>guard</code>s and <code>compile_if</code>s.</td></tr>
<tr><td>continuation</td><td>Create a suggested path or paths for a contract to be spent that are not guaranteed via CTV with mandatory <code>guard</code>s and <code>compile_if</code>s. Also accepts an update argument for generating transactions based on future data.</td></tr>
<tr><td>decl_*!</td><td>For any of the above, declare the existence of a method, for e.g. a trait definition, without defining the function.</td></tr>
</tbody></table>
<p>This section will teach you then ins and outs of each.</p>
<h1 id="guard"><a class="header" href="#guard">Guard</a></h1>
<p>Guards are central to any Sapio contract. They allow declaring a piece of
miniscript logic.</p>
<p>These guards can either be used standalone as unlocking conditions or as a
requirement on a <code>continuation</code> or <code>then</code> function.</p>
<p>If a <code>guard</code> is marked as cached, the compiler will make an effort to only
invoke the <code>guard</code> once during compilation. This is helpful in contexts
where a <code>guard</code> might be expensive to call, e.g. if it is programmed to
retrieve a <code>Clause</code> from a remote server. It is not guaranteed that the
<code>guard</code> is only invoked once.</p>
<h2 id="guard-macro"><a class="header" href="#guard-macro">guard macro</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[guard(
    /// optional: if the compiler should attempt to only call this guard one time (not guaranteed)
    cached)]
fn name(self, ctx: Context) {/*Clause*/}
decl_guard!{name};
<span class="boring">}
</span></code></pre></pre>
<h1 id="conditionallycompileif"><a class="header" href="#conditionallycompileif">ConditionallyCompileIf</a></h1>
<p><code>ConditionallyCompileIf</code> enables a contract writer to evaluate certain
value-based logic before evaluating a path function.</p>
<p>If the return value(s) indicate that a branch should not be evaluated, it is
skipped.</p>
<h2 id="when-to-use-conditionallycompileif"><a class="header" href="#when-to-use-conditionallycompileif">When to Use ConditionallyCompileIf</a></h2>
<p>Suppose we're creating a super secure wallet vault, and we want a recovery
path that's only accessible if the amount of funds being sent to the contract is &lt; an amount.</p>
<p>We could write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[compile_if]
fn not_too_much(self, ctx: Context) {
    if ctx.funds() &gt; Self::MAX_FUNDS {
        ConditionallyCompileType::Never
    } else {
        ConditionalCompileType::NoConstraint
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>and apply it to the relevant paths.</p>
<h2 id="conditionalcompiletype-variants"><a class="header" href="#conditionalcompiletype-variants">ConditionalCompileType Variants</a></h2>
<p>There are many different ConditionalCompileType return values:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ConditionalCompileType {
    /// May proceed without calling this function at all
    Skippable,
    /// If no errors are returned, and no txtmpls are returned,
    /// it is not an error and the branch is pruned.
    Nullable,
    /// The default condition if no ConditionallyCompileIf function is set, the
    /// branch is present and it is required.
    Required,
    /// This branch must never be used
    Never,
    /// No Constraint, nothing is changed by this rule
    NoConstraint,
    /// The branch should always trigger an error, with some reasons
    Fail(LinkedList&lt;String&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>These values are merged according to specific &quot;common sense&quot; logic. Please
see <code>ConditionalCompileType::merge</code> for details.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    ///     Fail &gt; non-Fail ==&gt; Fail
    ///     forall X. X &gt; NoConstraint ==&gt; X
    ///     Required &gt; {Skippable, Nullable} ==&gt; Required
    ///     Skippable &gt; Nullable ==&gt; Skippable
    ///     Never &gt;&lt; Required ==&gt; Fail
    ///     Never &gt; {Skippable, Nullable}  ==&gt; Never
<span class="boring">}
</span></code></pre></pre>
<h1 id="compile_if-macro"><a class="header" href="#compile_if-macro">compile_if! macro</a></h1>
<p>The <code>compile_if</code> macro can be called two ways:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[compile_if]
fn name(self, ctx) {
    /*ConditionalCompileType*/
}
/// null implementation
decl_compile_if!{name}
<span class="boring">}
</span></code></pre></pre>
<h1 id="thenfunc"><a class="header" href="#thenfunc">ThenFunc</a></h1>
<p>A <code>ThenFunc</code> is a continuation of a contract that can proceed when all the
guarded_by conditions on that object are met. The <code>ThenFunc</code> provides an
iterator of possible next transactions, using CTV to ensure execution.</p>
<h2 id="when-to-use-a-thenfunc"><a class="header" href="#when-to-use-a-thenfunc">When to use a ThenFunc</a></h2>
<p>We've already seen an example of a <code>then</code> function in the wild in <a href="./ch01-03-hello-world.html">Chapter
1</a>. In that example we are guaranteeing that after
a timeout, a specific &quot;return policy&quot; is honored out of the escrow. Unless
Alice and Bob agree to something else, the funds can only be returned via
that transaction.</p>
<p>In general, any time you want a state transition to be &quot;locked in&quot; you should use a <code>then!</code>.</p>
<h2 id="then-macro"><a class="header" href="#then-macro">then! macro</a></h2>
<p>The <code>then</code> macro generates a static <code>fn() -&gt; Option&lt;ThenFunc&gt;</code> method for a given impl.</p>
<p>There are a few variants of how you can create a <code>then</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A Conditional + Guarded CTV Function
#[then(
    /// optional: only compile these branches if these compile_if statements permit
    compile_if= &quot;[compile_if_1, ... compile_if_n]&quot;,
    /// optional: protect these branches with the conjunction (and) of these clauses
    guarded_by= &quot;[guard_1, ... guard_n]&quot;
)]
fn name(self, ctx) {
    /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
}
/// Null Implementation
decl_then!{name}
<span class="boring">}
</span></code></pre></pre>
<p>The Iterator must not be empty, or it will cause an error.</p>
<h1 id="finishorfunc"><a class="header" href="#finishorfunc">FinishOrFunc</a></h1>
<p>A <code>FinishOrFunc</code> is a continuation of a contract that <em>may</em> terminate when
all the guarded_by conditions on that object are met, but provides logic for some default continuations and logic for new continuations in light of new information.</p>
<p><code>FinishOrFunc</code>s do not use CTV to ensure execution.</p>
<h2 id="when-to-use-a-finishorfunc"><a class="header" href="#when-to-use-a-finishorfunc">When to use a FinishOrFunc</a></h2>
<p>An example of where a <code>FinishOrFunc</code> could be used is a multisig escrow contract, where if n-of-n interested parties agree to move the funds, the funds can move to any transaction. However, perhaps the escrow operators typically emit a payment to a third party and carry the remaining balances to a new escrow. A <code>FinishOrFunc</code> can provide convenient logic shared by all participants for generating what that next transaction should look like.</p>
<h2 id="finish-macro"><a class="header" href="#finish-macro">finish! macro</a></h2>
<p>The <code>continuation</code> macro generates a static <code>fn() -&gt; Option&lt;FinishOrFunc&gt;</code> method for a given impl.</p>
<p>There are a few variants of how you can create a <code>continuation</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateType;
/// Helper
fn default_coerce(
    k: &lt;T as Contract&gt;::StatefulArguments,
) -&gt; Result&lt;UpdateType, CompilationError&gt; {
    Ok(k)
}
/// A Guarded CTV Function
#[continuation(
    /// required: guards for the miniscript clauses required
    guarded_by = &quot;[Self::guard_1,... Self::guard_n]&quot;,
    /// optional: Conditional compilation
    compile_if = &quot;[Self::compile_if_1, ... Self::compile_if_n]&quot;,
    ///  optional: Enables compiling this for a json callable continuation
    web_api,
    /// helper for coercing args for json api, could be arbitrary
    coerce_args = &quot;default_coerce&quot;
)]
fn name(self, ctx:Context, o:UpdateType) {
    /*Result&lt;Box&lt;Iterator&lt;TransactionTemplate&gt;&gt;&gt;*/
}
/// Null Implementation
decl_finish!(name);
<span class="boring">}
</span></code></pre></pre>
<p>The parameter <code>o</code> is either called directly or attempted to be coerced from the
higher level <code>&lt;Self as Contract&gt;::StatefulArguments</code> which mus enum wrap the
arguments. This means that each <code>continuation</code> can have a unique parameter type,
but also be represented as a trait object with a single type. Enums may be used
to pass different arguments to different functions.</p>
<h1 id="when-to-use-macros"><a class="header" href="#when-to-use-macros">When to use macros?</a></h1>
<p>Generally, you want to use <code>continuation</code>, <code>then</code>, <code>guard</code>, etc to generate your
methods.  However, if you prefer to create them manually, it's entirely possible
to do so without much effort. A tool like <code>cargo expand</code> may be useful as you
can just copy the macro output and customize from there.</p>
<p>One reason you might choose to manually define them is if you want to have
custom static logic (that is, known just from the type and not a value-filled
instance) to decide if a method should be <code>Some</code> or <code>None</code>. If it does not need
to be static logic, a <code>compile_if</code> can be used, or the static logic can go
inside a <code>compile_if</code>.</p>
<h1 id="contract-declarations"><a class="header" href="#contract-declarations">Contract Declarations</a></h1>
<h2 id="static-contracts"><a class="header" href="#static-contracts">Static Contracts</a></h2>
<p>This is the usual way to declare a contract for Sapio.</p>
<p>Once a contract and all relevant logic has been defined, a <code>impl Contract</code>
should be written. This binds the functionality to the compiler interface.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Contract for T {
    declare!{then, Self::a, Self::b}
    declare!{finish, Self::guard_1, Self::guard_2}
    /// if there are finish! functions
    declare!{updatable&lt;Z&gt;, Self::updatable_1}
    /// if there are no updatable functions
    declare!{non updatable}
}
<span class="boring">}
</span></code></pre></pre>
<p>The type <code>Z</code> above becomes bound for the updatable functions.</p>
<h2 id="dynamic-contracts"><a class="header" href="#dynamic-contracts">Dynamic Contracts</a></h2>
<p>Sapio also supports several &quot;Dynamic Contract&quot; paradigms which allows a user
to assemble contracts at run-time. The two main paradigms are accomplished by
either directly <code>impl AnyContract</code> or by using the <code>DynamicContract</code> struct
which holds all functions in vecs.</p>
<p>These are useful in rare circumstances.</p>
<h2 id="external-addresses"><a class="header" href="#external-addresses">External Addresses?</a></h2>
<p>The compiler is able to &quot;lift&quot; an address or a script into a contract via
<code>Object::from_address</code> and <code>Object::from_script</code>. Care should be taken when
doing so as Sapio will not be able to provide any further API data beyond such a bound.</p>
<h1 id="contract-compilation-overview"><a class="header" href="#contract-compilation-overview">Contract Compilation Overview</a></h1>
<p>When the compiler sees a new contract, it proceeds by processing each path
item one at a time. If the order of compilation is important for your contract:</p>
<ol>
<li>reconsider your priorities</li>
<li>repeat step 1</li>
<li>read the logic inside of the <code>Compilable::compile</code> function</li>
</ol>
<p>This logic may be improved over time to take advantage of parallelization or
otherwise restructure. As such, one should be careful when switching compiler
versions. Further, optimizers or data structures may be unstable with respect to
things like renamed functions leading to changes of compilation result.</p>
<h2 id="determinism"><a class="header" href="#determinism">Determinism?</a></h2>
<p>Sapio is designed to be determinism-friendly. Repeated runs of the same
program should -- unless the user includes entropy -- return the same
results.</p>
<p>However, at writing, this property is not closely audited for, so outputs
should be treated as required to be stored in order to use a contract.</p>
<p>On the other hand, determinism means that for multi-party contracts being
generated in a Replicated state machine, if all parties have the same e.g.
WASM plugin, they can generate a contract definition and check that the
merkle root (in this case, a bitcoin address) is the same. If it differs,
either the arguments differed, someone cheated, or there was unexpected
non-determinism.</p>
<h1 id="continuation-effects"><a class="header" href="#continuation-effects">Continuation Effects</a></h1>
<p>Suppose we had the following bit of code in a contract's implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct PayToKey(bitcoin::PublicKey);
/// Helper
fn default_coerce(
    k: &lt;T as Contract&gt;::StatefulArguments,
) -&gt; Result&lt;PayToKey, CompilationError&gt; {
    Ok(k)
}
/// A Guarded CTV Function
#[continuation(
    /// required: guards for the miniscript clauses required
    guarded_by = &quot;[Self::guard_1,... Self::guard_n]&quot;,
    web_api,
    /// helper for coercing args for json api, could be arbitrary
    coerce_args = &quot;default_coerce&quot;
)]
fn to_address(self, ctx:Context, o:PayToKey) {
    let amt = ctx.funds();
    ctx.template().add_output(amt, &amp;o.0, None)?.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>When the <code>to_address</code> function gets passed by the compiler, a unique pointer (an effect path) is
generated for it from the context object. This enabled sending it parameters
later in the future.</p>
<p>On creation of the context object a <code>effects: Arc&lt;MapEffectDB&gt;</code> parameter  is
available.  This <code>MapEffectDB</code> links the effect paths to a list of arguments
intended to be passed to this branch which can generate new contract transitions
intended to be signed off on by the guards to that path.</p>
<p>For example, consider a contract for a NFT (a provenance checkable certificate
of ownership).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct NFT(bitcoin::PublicKey);

#[derive(Serialize, Deserialize)]
struct Sale(bitcoin::PublicKey, AmountF64);
/// Helper
fn default_coerce(
    k: &lt;T as Contract&gt;::StatefulArguments,
) -&gt; Result&lt;Sale, CompilationError&gt; {
    Ok(k)
}
impl NFT {
    #[guard]
    fn signed(self, ctx:Context) {
        Clause::Key(self.0)
    }
    #[continuation(
        guarded_by = &quot;[Self::signed]&quot;,
        web_api,
        /// helper for coercing args for json api, could be arbitrary
        coerce_args = &quot;default_coerce&quot;
    )]
    fn make_sale(self, ctx:Context, o:Sale) {
        let amt = ctx.funds();
        ctx.template()
           .add_amount(o.1)
           // Carry whatever funds in the UTXO to the buyer in
           // a new NFT
           .add_output(amt, &amp;NFT(o.0), None)?
           // Pay the sale amount to the previous owner
           .add_output(amt, &amp;self.0, None)?
           .into()
    }
}
impl Contract for NFT {
    declare!{updatable&lt;Sale&gt;, Self::make_sale}
}
<span class="boring">}
</span></code></pre></pre>
<p>The updates generated through <code>make_sale</code> generate the transactions for a series
of sales. For example, imagine I start with a <code>NFT(Bob)</code>.</p>
<p>I can recompile <code>NFT(Bob)</code> with the context (not exactly the pointer, but just for example)
<code>NFT(Bob)</code> with effects</p>
<pre><code class="language-json">{&quot;0&quot;: {&quot;make_sale&quot;: [[&quot;Alice&quot;, 10]]}}
</code></pre>
<p>Supposing Alice pays into the transaction, a future transaction could be:</p>
<pre><code class="language-json">{&quot;0&quot;: {&quot;make_sale&quot;: [[&quot;Alice&quot;, 10]]}, &quot;1&quot;: {&quot;make_sale&quot;: [[&quot;Carol&quot;, 11]]}}
</code></pre>
<p>Thus by starting with a known valid NFT (e.g., Bob being the original artist),
the effects can regenerate a series of state transitions for verification of
provenance.</p>
<p>Further, as effects at a given point are a set, there could be multiple in flight transitions. E.g.,</p>
<pre><code class="language-json">{&quot;0&quot;: {&quot;make_sale&quot;: [[&quot;Alice&quot;, 10], [&quot;Eve&quot;, 10]]}}
</code></pre>
<p>represents Alice and Bob both having the ability to purchase the NFT for 10 BTC.</p>
<h1 id="challenges-1"><a class="header" href="#challenges-1">Challenges</a></h1>
<ol>
<li>By using decreasing time locks, implement a dutch auction pitting two
participants against each other.</li>
</ol>
<h1 id="sapio-for-fun-and-profit"><a class="header" href="#sapio-for-fun-and-profit">Sapio for Fun (and Profit)</a></h1>
<p>In this section, we're going to build a simple option contract. This sort of
contract could be used, for example, to make an on-chain asynchronous offer to
someone to enter a bet with you.</p>
<p>Then, you'll have some challenges to modify the contract to extend it's
functionality meaningfully.</p>
<p>The logic for the basic contract is as follows:</p>
<ol>
<li>If \(\tau_{now} &gt; \tau_{timeout} \):
<ul>
<li>send funds to return address</li>
</ul>
</li>
<li>If <code>strike_price</code> btc are added:
<ul>
<li>send funds + <code>strike_price</code> to strike_into contract</li>
</ul>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Data Fields required to create a on-chain bet
pub struct UnderFundedExpiringOption {
    /// How much money has to be paid to strike the contract
    strike_price: Amount,
    /// if the contract expires, where to return the money
    return_address: bitcoin::Address,
    /// if the contract strikes, where to send the money
    strike_into: Box&lt;dyn Compilable&gt;,
    /// the timeout (as an absolute time) when the contract should end.
    timeout: AnyAbsTimeLock,
}

impl UnderFundedExpiringOption {
    #[then]
    /// return the funds on expiry
    fn expires(self, ctx: Context) {
        ctx.template()
            // set the timeout for this path -- because it is using
            // then! we do not require a guard.
            .set_lock_time(self.timeout)?
            .add_output(
                // ctx.funds() knows how much money has been sent to this contract
                ctx.funds(),
                // this bootstraps an address into a contract object
                &amp;Compiled::from_address(self.return_address.clone(), None),
                None,
            )?
            .into()
    }
    /// continue the contract
    #[then]
    fn strikes(self, ctx: Context) {
        let tmpl = ctx.template().add_amount(self.strike_price);
        let amt = (tmpl.ctx().funds() + self.strike_price).into();
        tmpl.add_sequence()
            .add_output(
                // use the inner context of tmpl because it has added funds
                amt,
                self.strike_into.as_ref(),
                None,
            )?
            .into()
    }
}

impl Contract for UnderFundedExpiringOption {
    declare!(then, Self::expires, Self::strikes);
    declare!(non updatable);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="challenges-2"><a class="header" href="#challenges-2">Challenges</a></h1>
<p>There's no right answer to the following challenges, and the resulting
contract may not be too useful, but it should be a good exercise to learn
more about writing Sapio contracts.</p>
<ol>
<li>Clear out your helloworld plugin and put this code in.</li>
<li>Write a contract designed to be put into the <code>strike_into</code> field which
sends funds to one party or the other based on a third-party revealing a
hash preimage <code>A</code> or <code>B</code>.</li>
<li>Modify the contract so that there is a <code>expire_A</code> and a <code>expire_B</code> path
that go to different addresses, and <code>expire_A</code> requires a signature or hash
reveal to be taken.</li>
<li>Modify the contract so that if <code>expire_A</code> is taken, a small payout
<code>early_exit_fee: bitcoin::Address</code> is made to a <code>early_exit : bitcoin::Address</code>.</li>
<li>Modify the contract so that <code>expire_A</code> is only present the fields required
by it are <code>Option::is_some</code> (hint: use <code>compile_if!</code>).</li>
<li>Add logic to deduct fees.</li>
<li>Add a <code>cooperative_close</code> <code>guard!</code> clause that allows both parties to exit gracefully</li>
</ol>
<h1 id="limitations-of-sapio"><a class="header" href="#limitations-of-sapio">Limitations of Sapio</a></h1>
<p>Sapio is rapidly maturing, but it is still early-days for bitcoin smart
contract compilers, and early-days for Sapio in particular. As such, one
should be careful to closely audit smart contracts designed with Sapio, be
careful to only use such contracts with trusted inputs, and in general take
precautions to ensure security of funds. As Sapio matures and we gain
confidence in smart contracts built with it, Sapio should be able to greatly
improve the security for many bitcoin users and applications.</p>
<p>Other than these general &quot;alpha software&quot; disclaimers, Sapio is designed with
certain upgrades to Bitcoin in mind that have not yet landed. While Sapio is
designed to work even without these upgrades, the functionality is severely
reduced or has a different security model.</p>
<p>This section goes over some of these limitations and when we might expect to
see them addressed.</p>
<h1 id="bip-119-emulation"><a class="header" href="#bip-119-emulation">BIP-119 Emulation</a></h1>
<p>Changes to Bitcoin take a long time. The star player in making Sapio work is
BIP-119, and that might take a while to get merged. To get around this, Sapio
provides some tools to enable similar functionality today by emulating
BIP-119 with signatures.</p>
<h2 id="the-default-emulator"><a class="header" href="#the-default-emulator">The Default Emulator</a></h2>
<p>Sapio CTV Emulators defines implementations of a local emulator that can be
used by sapio compiler library users. To use such an emulator, a user can
generate a seed and create a contract. After creating the contract and
binding it to a specific UTXO, a user should be able to delete the seed,
ensuring that only the compiled logic may be used. Alternatively, they can
retain the seed and promise not to improperly use it.</p>
<p>This crate also defines logic for servers that want to offer emulator
services to remote compilers. This is convenient since the emulator server
must be kept secure, so an organization may want it to be more tightly
safeguarded.</p>
<p>The emulator definitions include wrapper types that compose individual
instances of an emulator into a federated multisig. This is useful
for circumstances where a contract is between e.g. 2 parties and both
have an emulator server. Then the contract can be &quot;immutable&quot; unless
both collude.</p>
<p>To aid in experimentation, Judica, Inc operates a public emulator server for
regtest.</p>
<pre><code class="language-json">[
    &quot;tpubD6NzVbkrYhZ4Wf398td3H8YhWBsXx9Sxa4W3cQWkNW3N3DHSNB2qtPoUMXrA6JNaPxodQfRpoZNE5tGM9iZ4xfUEFRJEJvfs8W5paUagYCE&quot;,
    &quot;ctv.d31373.org:8367&quot;
]
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p><em>See the source code for more detailed documentation.</em></p>
<p>CheckTemplateVerify essentially functions as a self-signed transaction. I.e.,
imagine you could create a public key that could only ever sign a transaction
which matched a certain pattern?</p>
<p>To implement this functionality, we use BIP-32 HD keys with public derivation.</p>
<p>On initialization, a server picks a seed S and generates a root public key K
from it, and publishes K.</p>
<p>Users generate a transaction T and extract the CheckTemplateVerify hash H for
it. They then take H and convert it into a derivation path D of 8 u32's and 1
u8 for non-hardened derivation (see <code>hash_to_child_vec</code>).</p>
<p>This derivation path is then applied to K to generate a key C. This key is
added with a CheckSig(SIGHASH_ALL) to the script in place of a CTV clause.</p>
<p>Then, when a user desires to spend an output with such a key, they create the
entire transaction they want to occur and send it to the emulator server.</p>
<p>Without even checking to see that the key is used in the transaction, the
server generates the template hash H' (which should equal H) and then signs,
returning the signature to the client.</p>
<p>Before creating a contract, clients may wish to collect all possible
signatures required to prevent an availability fault.</p>
<p>This scheme has the benefit that:</p>
<ol>
<li>contract specification can occur without any online processes</li>
<li>The server has no intelligent logic, all guarantees are structural.</li>
<li>Server is completely stateless.</li>
<li>Availability/malfeasance can be controlled for with multisig</li>
<li>1:1 functionality mapping to CTV</li>
</ol>
<p>The downside of this approach to emulation is that:</p>
<ol>
<li>It is somewhat inefficient for scripts which have many branched possibilities.</li>
<li>No inherent mechanism to delete keys after use to protect against future exfiltration.</li>
</ol>
<h4 id="why-bip-32"><a class="header" href="#why-bip-32">Why BIP-32</a></h4>
<p>We use BIP-32 because it is a well studied primitive and derivation paths are
compatible with existing signing hardware. While it is true that a tweak of
32 bytes could be directly applied to the key more efficiently, easier
interoperability with existing tools seemed to be the best path.</p>
<h2 id="customizing-emulator-trait"><a class="header" href="#customizing-emulator-trait">Customizing Emulator Trait</a></h2>
<p>This emulator trait crate is a base that exports a trait definition and some
helper structs that are needed across the sapio ecosystem.</p>
<p>Defining the trait in its own crate allows us to use trait objects in our
compiler internals without needing to have the compiler directly depend on
e.g. networking primitives.</p>
<p>As a user of the Sapio library, you can define your own custom emulator logic
but that's out of scope of this book.</p>
<h2 id="future-work"><a class="header" href="#future-work">Future Work</a></h2>
<p><a href="https://github.com/sapio-lang/sapio/issues/100">There is a plan</a> to make
emulation more efficient based on Merkelization, but it is not yet
implemented because it messes with the current way the compiler works.</p>
<p>The efficiency issues are also solvable, more or less, with taproot.</p>
<h1 id="taproot"><a class="header" href="#taproot">Taproot</a></h1>
<p>Sapio contract logic can become very large in size, so Sapio benefits from
being able to split up and merkelize the logic into smaller satisfiable
chunks. This makes it much more economical and easy to use Sapio however you like.</p>
<p>Generally speaking, a Sapio programmer need not think about this too much, it will be set up
automatically under the hood. However, at writing, limited optimizing of Taproot trees is done,
so a wise programmer would want to express their program in such a way to not allow Taproot leafs to be larger than need be.</p>
<h1 id="advanced-transaction-handling"><a class="header" href="#advanced-transaction-handling">Advanced Transaction Handling</a></h1>
<p>Sapio does not try to handle all possible types of Bitcoin transactions.</p>
<p>There are certain &quot;advanced techniques&quot; that have use cases, but are
difficult to reason about. For example, there are many ways that SIGHASH
flags can be exploited to create all sorts of possibilities. You can use
<code>OP_2DUP OP_SHA256 &lt;H1&gt; OP_EQUALVERIFY OP_SWAP OP_SHA256 &lt;H2&gt; OP_EQUALVERIFY OP_SIZE OP_SWAP OP_SIZE OP_EQUAL</code> (or something similar) to flip a fair coin between participants. There is a <em>lot</em>.</p>
<p>But Sapio doesn't make an effort to cleanly handle all possible contracts. It
makes an effort to address a safe and useful subset and make those contracts
well integrated with other standard software.</p>
<p>If you identify a killer use-case contract, please open an issue or a PR to
discuss the new functionality and how to add it.</p>
<h1 id="mempool--fees"><a class="header" href="#mempool--fees">Mempool &amp; Fees</a></h1>
<p>The Mempool is a treacherous place. If you're not familiar, the Mempool is
Bitcoin's backlog of unconfirmed transactions. It is a bounded queue which makes a best
effort at storing transactions that pay higher fees and dropping transactions which
pay insufficient fees.</p>
<p>The Mempool is an issue for a Sapio user because Sapio contracts are
generally immutable, which implies that Sapio contracts have to estimate the
minimum feerates at the time of contract creation.</p>
<p>For example, suppose I make a contract that has a state transition paying a
200 sats per vbyte feerate. And then by the time that transaction reaches the
mempool, it has gone up to 201 sats per vbyte minimum. Now I cannot easily
broadcast my transaction, and it is unlikely to wind up in a block.</p>
<p>There are many other ways that transactions can end up stuck.</p>
<p>Fortunately, there are some solutions to these sorts of problems, but none of
them are exactly &quot;easy&quot;. We'll divide them in three categories:</p>
<h1 id="careful-contract-programming"><a class="header" href="#careful-contract-programming">Careful Contract Programming</a></h1>
<p>Careful contract programming can ensure that:</p>
<ol>
<li>All contract transitions pay a high enough minimum we expect to be able to get into the mempool in the future</li>
<li>There are ways to inject &quot;gas inputs&quot; into the contract, if needed</li>
<li>There are ways to spend &quot;gas outputs&quot; from the contract just for Child-Pays-For-Parent logic.</li>
<li>Relative timelocks are used to prevent pinning attacks</li>
</ol>
<p>For a discussion of this topic with visuals, please see the Sapio Reckless VR
Talk section on fees:</p>
<p>TODO: Integrate this content into writing</p>
<ul>
<li><a href="https://diyhpl.us/wiki/transcripts/vr-bitcoin/2020-07-11-jeremy-rubin-sapio-101/">notes</a></li>
<li><a href="https://docs.google.com/presentation/d/1X4AGNXJ5yCeHRrf5sa9DarWfDyEkm6fFUlrcIRQtUw4/edit#slide=id.g8bddfc449f_0_358">slides</a></li>
<li><a href="https://youtu.be/4vDuttlImPc?t=1665">video</a></li>
</ul>
<div style="padding-bottom: 56.25%; position: relative;">
 <iframe style="position:absolute; top:0; left:0; width:100%; height: 100%;" src="https://www.youtube.com/embed/4vDuttlImPc?start=1665"
                                  frameborder="0" allow="accelerometer; autoplay; encrypted-media;
                                               gyroscope; picture-in-picture"
                                                  allowfullscreen></iframe>
</div>
<h1 id="p2p-networkmempool-policy-changes"><a class="header" href="#p2p-networkmempool-policy-changes">P2P Network/Mempool Policy Changes</a></h1>
<p>Package Relay is a proposed technique that is progressing for Bitcoin whereby
multiple transactions can be submitted in one bundle to show suitability for
the mempool. Therefore a contract leaf node might be able to demonstrate, by
spending the coin, that the contract interior nodes are worth mining.</p>
<p>However, this technique is limited insofar as contract interior nodes in
Sapio may commonly have relative time locks (or similar) which prevent the
mempool from considering dependents.</p>
<p>Package Relaying does, however, improve the function of intentional gas outputs.</p>
<h1 id="consensus-changes"><a class="header" href="#consensus-changes">Consensus Changes</a></h1>
<p>Consensus changes are very difficult to create, but it's possible that in the
future some set of consensus changes help decouple contract execution from fee paying.</p>
<p>For example, there is a
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html">proposal</a>
to replace Replace-By-Fee and Child-Pays-For-Parent with a mechanism that
functions as a virtual CPFP link. However, such proposals can introduce
subtle changes to Bitcoin's behavior and must be vetted closely.</p>
<h1 id="application-packaging"><a class="header" href="#application-packaging">Application Packaging</a></h1>
<p>So you've written a Sapio contract and you're ready to get it out into the
world.</p>
<p>How should you release it? How should you use it?</p>
<p>This section covers various ways to deploy and use Sapio contracts.</p>
<p>In general, it is important to make the code available in an open source way,
so others can integrate and use your contracts. Rust's <a href="https://crates.io">crates</a>
system provides a natural place to publish for the time being, although
in the future we may build a Sapio specific package manager as smart contracts
have some unique differences.</p>
<h1 id="wasm"><a class="header" href="#wasm">WASM</a></h1>
<p>WASM is &quot;WebAssembly&quot;, or a standard for producing bytecode objects that can
be run on any platform. As the name suggests, it was originally designed for
use in web browsers as a compiler target for any language to produce code to
run safely from untrusted sources.</p>
<p>So what's it doing in Sapio?</p>
<p>WASM is designed to be cross platform and deterministic, which makes it a
great target for smart contracts that we want to be able to be reproduced
locally. It also makes it <em>relatively</em> safe to run smart contracts provided
by untrusted parties as the security of the WASM sandbox prevents bad code from
harming or infecting our system.</p>
<p>Sapio Contract objects can be built into  WASM binaries very easily. The code required is basically:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// MyContract must support Deserialize and JsonSchema
#[derive(Deserialize, JsonSchema)]
struct MyContract;
impl Contract for MyContract{\*...*\};
/// binds to the plugin interface -- only one REGISTER macro permitted per project
REGISTER![MyContract];
<span class="boring">}
</span></code></pre></pre>
<p>See <a href="https://github.com/sapio-lang/sapio/tree/master/plugin-example">the example</a> for more details.</p>
<p>These compiled objects require a special environment to be interacted with.
That environment is provided by the <a href="./ch07-00-cli.html">Sapio CLI</a> as a
standalone binary. It is also possible to use the interface provided by the
<code>sapio-wasm-plugin</code> crate to load a plugin from your rust codebase
programmatically. Lastly, one could create similar bindings for another
platform as long as a WASM interpreter is available.</p>
<h2 id="cross-module-calls"><a class="header" href="#cross-module-calls">Cross Module Calls</a></h2>
<p>The WASM Plugin Handle architecture permits one WASM plugin to call into
another. This is incredibly powerful. What this enables one to do is to
package Sapio contracts that are generic and can call one another either by
hash (with effective subresource integrity) or by a nickname (providing easy
user customizability).</p>
<p>For example, suppose I was writing a standard contract component <code>C</code> which I
publish. Then later, I develop a contract <code>B</code> which is designed to work with
<code>C</code>. Rather than having to depend on <code>C</code>'s source code (which I may not want
to do for various reasons), I could simply hard code <code>C</code>'s hash into <code>B</code> and
call <code>create_contract_by_key(key: &amp;[u8; 32], args: Value, amt: Amount)</code> to
get the desired code. The plugin management system automatically searches for
a contract plugin with that hash, and tries to call it with the provided JSON
arguments. Using <code>create_contract(key:&amp;str, args:Value: amt:Amount)</code>, a
nickname can be provided in which case the appropriate plugin is resolved by
the environment.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct C;
const DEPENDS_ON_MODULE : [u8; 32] = [0;32];
impl Contract for C {
    #[then]
    fn demo(self, ctx: Context) {
        let amt = ctx.funds()/2;
        ctx.template()
            .add_output(amt, &amp;create_contract(&quot;users_cold_storage&quot;, /**/, amt), None)?
            .add_output(amt, &amp;create_contract(&amp;DEPENDS_ON_MODULE, /**/, amt), None)?
            .into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="typed-calls"><a class="header" href="#typed-calls">Typed Calls</a></h3>
<p>Using JSONSchemas, plugins have a basic type system that enables run-time
checking for compatibility. Plugins can guarantee they implement particular
interfaces faithfully. These interfaces currently only support protecting the
call, but make no assurances about the returned value or potential errors from
the callee's implementation of the trait.</p>
<p>For example, suppose I want to be able to specify a provided module must
statisfy a calling convention for batching. I define the trait
<code>BatchingTraitVersion0_1_1</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A payment to a specific address
#[derive(JsonSchema, Serialize, Deserialize, Clone)]
pub struct Payment {
    /// The amount to send
    #[serde(with = &quot;bitcoin::util::amount::serde::as_btc&quot;)]
    #[schemars(with = &quot;f64&quot;)]
    pub amount: bitcoin::util::amount::Amount,
    /// # Address
    /// The Address to send to
    pub address: bitcoin::Address,
}
#[derive(Serialize, JsonSchema, Deserialize, Clone)]
pub struct BatchingTraitVersion0_1_1 {
    pub payments: Vec&lt;Payment&gt;,
    #[serde(with = &quot;bitcoin::util::amount::serde::as_sat&quot;)]
    #[schemars(with = &quot;u64&quot;)]
    pub feerate_per_byte: bitcoin::util::amount::Amount,
}
<span class="boring">}
</span></code></pre></pre>
<p>I can then turn this into a SapioJSONTrait by implementing the trait and
providing an &quot;example&quot; function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SapioJSONTrait for BatchingTraitVersion0_1_1 {
    /// required to implement
    fn get_example_for_api_checking() -&gt; Value {
        #[derive(Serialize)]
        enum Versions {
            BatchingTraitVersion0_1_1(BatchingTraitVersion0_1_1),
        }
        serde_json::to_value(Versions::BatchingTraitVersion0_1_1(
            BatchingTraitVersion0_1_1 {
                payments: vec![],
                feerate_per_byte: bitcoin::util::amount::Amount::from_sat(0),
            },
        ))
        .unwrap()
    }

    /// optionally, this method may be overridden directly for more advanced type checking.
    fn check_trait_implemented(api: &amp;dyn SapioAPIHandle) -&gt; bool {
        Self::check_trait_implemented_inner(api).is_ok()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If a contract module can receive the example, then it is considered to have
implemented the API. We can implement the receivers for a module as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MockContract;
/// # Different Calling Conventions to create a Treepay
#[derive(Serialize, Deserialize, JsonSchema)]
enum Versions {
    /// # Base
    Base(MockContract),
    /// # Batching Trait API
    BatchingTraitVersion0_1_1(BatchingTraitVersion0_1_1),
}
impl From&lt;BatchingTraitVersion0_1_1&gt; for MockContract {
    fn from(args: BatchingTraitVersion0_1_1) -&gt; Self {
        MockContract
    }
}
impl From&lt;Versions&gt; for TreePay {
    fn from(v: Versions) -&gt; TreePay {
        match v {
            Versions::Base(v) =&gt; v,
            Versions::BatchingTraitVersion0_1_1(v) =&gt; v.into(),
        }
    }
}
REGISTER![[MockContract, Versions], &quot;logo.png&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Now <code>MockContract</code> can be called via the <code>BatchingTraitVersion0_1_1</code> trait
interface.</p>
<p>Another module in the future need only have a field
<code>SapioHostAPI&lt;BatchingTraitVersion0_1_1&gt;</code>. This type verifies at deserialize
time that the provided name or hash key implements the required interface(s).</p>
<h3 id="future-work-on-cross-module-calls"><a class="header" href="#future-work-on-cross-module-calls">Future Work on Cross Module Calls</a></h3>
<ul>
<li><strong>Gitian Packaging:</strong> Using a gitian signed packaging distribution system
would enable a user to set up a web-of-trust setting for their sapio compiler
and enable fetching of sub-resources by hash if they've been signed by the
appropriate parties.</li>
<li><strong>NameSpace Registration:</strong> A system to allow people to register names
unambiguously would aid in ensuring no conflicts. For now, we can handle
this using a centralized repo.</li>
<li><strong>Remote CMC:</strong> In some cases, we may want to make a call to a remote
server that will call a given module for us. This might be desirable if the
server holds sensitive material that we shouldn't have.</li>
<li><strong>Concrete CMC:</strong> currently, CMC's only return the <code>Compiled</code> type. Perhaps
future <code>CMC</code> support can return arbitrary types, allowing other types of functionality
to be packaged.</li>
</ul>
<h1 id="rust-libbin"><a class="header" href="#rust-libbin">Rust Lib/Bin</a></h1>
<p>There's not much to be said here. Sapio code is just Rust code, so it can be
shipped as a standalone rust library or binary tool.</p>
<p>This code can then be integrated into any codebase either natively or using
FFI.</p>
<p>It's a good idea to always package contracts as a library separate from the
binary, so that if a user wants to natively incorporate the contract it is
easy to do, and the packaged WASM or binary can be a utility based on it.</p>
<h1 id="sapio-studio"><a class="header" href="#sapio-studio">Sapio Studio</a></h1>
<p><a href="https://github.com/sapio-lang/sapio-studio">Sapio Studio</a> is an in-development graphical user
interface for Sapio.</p>
<p>Currently, Sapio Studio works based on managing a WASM plugin directory, so that
users can more readily add contracts of their choosing.</p>
<p>Contracts packaged for WASM have some additional constraints or functionality
for aiding in the generation of a UX.</p>
<h1 id="sapio-command-line-interface-cli"><a class="header" href="#sapio-command-line-interface-cli">Sapio Command Line Interface (CLI)</a></h1>
<p>The Sapio CLI (or <code>sapio-cli</code>) is rapidly changing, but it is self
documenting using <code>cargo run sapio-cli help</code>.</p>
<p><code>sapio-cli</code> aids users in:</p>
<ol>
<li>compiling sapio contracts into templates</li>
<li>binding compiled templates to specific utxos from your bitcoin wallet</li>
<li>inspecting contract plugins</li>
<li>running emulator servers</li>
</ol>
<p><code>sapio-cli</code> has a config file (location dependent on platform, under
<code>org.judica.sapio-cli</code> e.g. <code>/home/&lt;usr&gt;/.config/sapio-cli/config.json</code>). The
config file can be overriden with the <code>-c</code> flag. This file allows users to set parameters
for compilation around:</p>
<ol>
<li>to use regtest/mainnet/signet/etc</li>
<li>bitcoind to connect to &amp; auth</li>
<li>CTV emulator servers to use</li>
<li>key-value mapping of nicknames to <a href="./ch06-01-wasm.html">WASM</a> plugin hashes.</li>
</ol>
<h1 id="advanced-rust-patterns"><a class="header" href="#advanced-rust-patterns">Advanced Rust Patterns</a></h1>
<p>Say it with me -- Sapio's Just Rust ™. Even though there's a lot of
additional paradigms and information to take in to use Sapio over normal Rust
programming, at the end of the day you can integrate Sapio into any Rust
paradigm you like.</p>
<p>That said, this section has a few useful patterns that merit specific mention
as you may find yourself reaching for them again and again.</p>
<h1 id="type-level-state-machines"><a class="header" href="#type-level-state-machines">Type Level State Machines</a></h1>
<p>In this example we use type level state machines to encode functionality that
is potentially available. See the example below for a sketch of how this can work.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The contract we're building, that can be in any type-state T.
struct StatefulContract&lt;T&gt;(PhantomData&lt;T&gt;);

/// We use empty structs as type tags.
/// Note: we could add a `trait State`, but it is not required
/// 
/// A contract can be in the open state or the closed state.
struct Opened;
struct Closed;

/// The &quot;state machine&quot; defines functionality that may be available
trait FunctionalityAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    decl_then!{do_something}
}


/// Override the impl when state is Opened
impl FunctionalityAtState for StatefulContract&lt;Opened&gt; {
  /// Transition from Opened =&gt; Closed state
    #[then]
    fn do_something(self, ctx: Context) {
        ctx.template()
            .add_output(
                ctx.funds(),
                &amp;StatefulContract::&lt;Closed&gt;(Default::default()),
                None,
            )?
            .into()
    }
}

/// do not override `do_something`, no branch will be generated
impl FunctionalityAtState for StatefulContract&lt;Closed&gt; {}

/// Register that all StatefulContract&lt;T&gt;'s that implement FunctionalityAtState
/// are Contracts
impl Contract for StatefulContract&lt;T&gt;
where Self : FunctionalityAtState {
    declare!{then, Self::do_something}
}
<span class="boring">}
</span></code></pre></pre>
<p>This technique is <em>ridiculously</em> powerful. Imagine, for instance, that we
wanted to have different sorts of state other than Open and Closed. E.g., Red
and Green. We could then define Transition Rules that encode a graph like:</p>
<pre><code>(Open, Green) ==&gt; do_something ==&gt; (Closed, Green)
(Open, Red) ==&gt; do_something ==&gt; (Closed, Red)
(Open, Green) ==&gt; do_something_else ==&gt;  (Open, Red)
(Open, Red) ==&gt; do_something_else ==&gt; (Closed, Red)
</code></pre>
<p>using two separate <code>FunctionalityAtState</code> like traits:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The contract we're building, that can be in any type-state T.
struct StatefulContract&lt;T1, T2&gt;(PhantomData&lt;(T1, T2)&gt;);

/// We use empty structs as type tags.
/// Note: we could add a `trait State`, but it is not required
/// 
/// A contract can be in the open state or the closed state.
struct Opened;
struct Closed;
// And Red or Green
struct Red;
struct Green;

/// The &quot;state machine&quot; defines functionality that may be available
trait OpenAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    delc_then!{do_something}
}

trait ColorAtState 
where Self : Sized + Contract
{
    /// empty declaration *could* be a default implementation, but we leave it empty
    /// so that other states may override it.
    decl_then!{do_something}
}


/// Override the impl when state is Opened
impl OpenAtState&lt;DontCare&gt; for StatefulContract&lt;Opened, DontCare&gt; {
    /// Transition from Opened =&gt; Closed state
    #[then]
    fn do_something(self, ctx: Context) {
        ctx.template()
            .add_output(
                ctx.funds(),
                &amp;StatefulContract::&lt;Closed, DontCare&gt;(Default::default()),
                None,
            )?
            .into()
    }
}

/// do not override `do_something`, no branch will be generated
impl OpenAtState&lt;DontCare&gt; for StatefulContract&lt;Closed, DontCare&gt; {}

/// Override the impl when state is Opened
impl ColorAtState for StatefulContract&lt;Open, Green&gt; {
    /// Transition from Green =&gt; Red state
    #[then]
    fn do_something_else(self, ctx: Context) {
        ctx.template()
            .add_output(
                ctx.funds(),
                &amp;StatefulContract::&lt;Open, Red&gt;(Default::default()),
                None,
            )?
            .into()
    }
}

impl ColorAtState for StatefulContract&lt;Open, Red&gt; {
    /// Transition from Open =&gt; Closed state
    #[then]
    fn do_something_else(self, ctx: Context) {
        ctx.template()
            .add_output(
                ctx.funds(),
                &amp;StatefulContract::&lt;Closed, Red&gt;(Default::default()),
                None,
            )?
            .into()
    }
}

/// do not override `do_something_else`, no branch will be generated
impl ColorAtState&lt;DontCare&gt; for StatefulContract&lt;DontCare, Red&gt; {}

/// Register that all StatefulContract&lt;T&gt;'s that implement OpenAtState
/// are Contracts
impl Contract for StatefulContract&lt;T&gt;
where Self : OpenAtState + ColorAtState {
    declare!{then, Self::do_something, Self::do_something_else}
}
<span class="boring">}
</span></code></pre></pre>
<p>This technique showcases how Sapio could encode very sophisticated logic in
program generation.</p>
<p>It's also notable that following rustc v1.51, it is possible to use <code>const</code>'s
as generic type parameters which enables even more computation at the type level.</p>
<h1 id="tryfrom-constructors"><a class="header" href="#tryfrom-constructors">TryFrom Constructors</a></h1>
<p>Often times we want to assure that various properties must be true about the
arguments passed to a contract instance.</p>
<p>By using TryFrom and being careful with the visibility of inner fields it is
possible to guarantee that the only way to get an X is by going through type
Y.</p>
<p>This can be bound using the <code>serde(try_from)</code> attribute, which makes it so
that any deserialization of <code>X</code> first passes through <code>Y</code>. This is
particularly useful when <code>X</code> contains types (such as function pointers or
caches) that cannot be deserialized, but we want to provide a way for a third
party to pass JSON args to construct an <code>X</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;
use std::convert::TryInto;
use serde::*;
/// inner argument not pub, X cannot be constructed without going through Y
#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(try_from=&quot;Y&quot;)]
pub struct X(u32);

#[derive(Serialize, Deserialize, JsonSchema)]
pub struct Y(pub u32);
impl TryFrom&lt;Y&gt; for X {
    type Error = &amp;'static str;
    fn try_from(y: Y) -&gt; Result&lt;Self, Self::Error&gt; {
        if y.0 &lt; 10 {
            Err(&quot;Too Small I Guess?&quot;)
        } else {
            Ok(X(y.0))
        }
    }
}

let x: X = Y(10).try_into().unwrap();

<span class="boring">}
</span></code></pre></pre>
<h1 id="concrete--generic-types"><a class="header" href="#concrete--generic-types">Concrete &amp; Generic Types</a></h1>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Often time, it can be useful to make a generic contract, such as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GenericA {
    send_to: Box&lt;dyn Compilable&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GenericB&lt;T:Compilable&gt; {
    send_to: T
}
<span class="boring">}
</span></code></pre></pre>
<p>In <code>GenericA</code> we use a <em>trait object</em> to allow us to let the <code>send_to</code> field
equal any <code>Compilable</code> type while having the same type <code>GenericA</code>,
whereas <code>GenericB</code> takes a type parameter that makes the <code>GenericB</code> more
specifically typed.</p>
<p>To highlight the differences between the approaches, suppose I had a parent contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, JsonSchema)]
struct ConcreteA;
#[derive(Serialize, Deserialize, JsonSchema)]
struct ConcreteB;
struct AliceAndBobFree {
    alice: GenericA;
    bob: GenericA;
}
/// inner types can differ
let example_free_ok = AliceAndBobFree { alice: GenericA{send_to: Box::new(ConcreteA)},
                                        bob: GenericA{send_to:Box::new(ConcreteB)}};

struct AliceAndBobRestricted&lt;T&gt; {
    alice: GenericB&lt;T&gt;;
    bob: GenericB&lt;T&gt;;
}

/// inner types cannot differ
let example_restricted_fails = AliceAndBobRestricted { alice: GenericB{send_to: ConcreteA},
                                                       bob: GenericB{send_to: ConcreteB}};
<span class="boring">}
</span></code></pre></pre>
<p>It might <em>seem</em> like you always want to use the <code>GenericA</code> variant, but there are cases where you
might want to guarantee that Alice and Bob's supplied contracts are the same type.</p>
<h2 id="concrete-wrappers"><a class="header" href="#concrete-wrappers">Concrete Wrappers</a></h2>
<p>When you do have a generic type (either with trait objects or otherwise) it
can be difficult to use across an application boundary. To get around this,
one can create a wrapper type (or enum) that uses the <a href="./ch08-03-concrete.html"><code>TryFrom</code>
paradigm</a> to provide paths for the type to be concrete. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, JsonSchema)]
enum Concrete {
    A(ConcreteA),
    B(ConcreteB),
}

impl TryFrom&lt;Concrete&gt; for GenericA {
    type Error = &amp;'static str;

    fn try_from(concrete:Concrete) -&gt; Result&lt;Self, Self::Error&gt; {
        match concrete {
            Concrete::A(a) =&gt; GenericA(Box::new(a)),
            Concrete::B(b) =&gt; GenericA(Box::new(b))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Thus a <code>Concrete</code> can be used in a Serialize/Deserialize/JsonSchema API bound
context, whereas a <code>GenericA</code> could not.</p>
<h3 id="todo-implement-path-for-making-this-section-easier"><a class="header" href="#todo-implement-path-for-making-this-section-easier">TODO: Implement path for making this section easier!</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
